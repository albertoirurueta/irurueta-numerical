<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CurveInterpolator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-numerical</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.numerical.interpolation</a> &gt; <span class="el_source">CurveInterpolator.java</span></div><h1>CurveInterpolator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2023 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.numerical.interpolation;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;

/**
 * Computes curve interpolation of multidimensional points using cubic splines.
 * This interpolator uses an ordered set of N tabulated points in dim dimensions that lie on
 * a one-dimensional curve, x0... xn-1, and interpolates values along the curve.
 */
public class CurveInterpolator {

    /**
     * Number of points dimensions.
     */
    private final int dim;

    /**
     * True indicates a closed curve, false indicates an open one.
     */
    private final boolean cls;

    /**
     * Result of interpolation.
     */
    private final double[] ans;

    /**
     * Array of one dimensional cubic spline interpolators.
     */
    private final CubicSplineInterpolator[] srp;

    /**
     * Constructor.
     *
     * @param ptsin matrix containing points on each row. Number of columns determines number of
     *              dimensions of each point.
     * @param close true indicates that points lie in a closed curve, false indicates they lie on
     *              an open one.
     * @throws InterpolationException if a numerical exception occurs.
     */
<span class="fc" id="L57">    public CurveInterpolator(final Matrix ptsin, final boolean close) throws InterpolationException {</span>
        try {
<span class="fc" id="L59">            final var n = ptsin.getRows();</span>
<span class="fc" id="L60">            dim = ptsin.getColumns();</span>
            // The trick for closed curves is to duplicate half a period at the beginning and end,
            // and then use the middle half of the resulting spline
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">            final var in = close ? 2 * n : n;</span>
<span class="fc" id="L64">            cls = close;</span>
<span class="fc" id="L65">            final var pts = new Matrix(dim, in);</span>
<span class="fc" id="L66">            final var s = new double[in];</span>
<span class="fc" id="L67">            ans = new double[dim];</span>
<span class="fc" id="L68">            srp = new CubicSplineInterpolator[dim];</span>

<span class="fc" id="L70">            final var p1 = new double[dim];</span>
<span class="fc" id="L71">            final var p2 = new double[dim];</span>
<span class="fc" id="L72">            final var p = new double[in];</span>
<span class="fc" id="L73">            final var end = dim - 1;</span>

            int i;
            int ii;
            int im;
            int j;
            int ofs;
            double ss;
            double soff;
            double db;
            double de;
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">            ofs = close ? n / 2 : 0;</span>
<span class="fc" id="L85">            s[0] = 0.;</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            for (i = 0; i &lt; in; i++) {</span>
<span class="fc" id="L87">                ii = (i - ofs + n) % n;</span>
<span class="fc" id="L88">                im = (ii - 1 + n) % n;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">                for (j = 0; j &lt; dim; j++) {</span>
                    // store transpose
<span class="fc" id="L91">                    pts.setElementAt(j, i, ptsin.getElementAt(ii, j));</span>
                }

<span class="fc bfc" id="L94" title="All 2 branches covered.">                if (i &gt; 0) {</span>
                    // Accumulate arc length
<span class="fc" id="L96">                    ptsin.getSubmatrixAsArray(ii, 0, ii, end, p1);</span>
<span class="fc" id="L97">                    ptsin.getSubmatrixAsArray(im, 0, im, end, p2);</span>
<span class="fc" id="L98">                    s[i] = s[i - 1] + rad(p1, p2);</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">                    if (s[i] == s[i - 1]) {</span>
                        // Consecutive points may not be identical. For a close curve, the last
                        // data point should not duplicate the first.
<span class="nc" id="L102">                        throw new InterpolationException();</span>
                    }
                }
            }

            // Rescale parameter so that the interval [0,1] is the whole curve (or one period)
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            ss = close ? s[ofs + n] - s[ofs] : s[n - 1] - s[0];</span>
<span class="fc" id="L109">            soff = s[ofs];</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            for (i = 0; i &lt; in; i++) {</span>
<span class="fc" id="L111">                s[i] = (s[i] - soff) / ss;</span>
            }

            // Construct the splines using endpoint derivatives
<span class="fc" id="L115">            final var endPts = in - 1;</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">            for (j = 0; j &lt; dim; j++) {</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">                if (in &lt; 4) {</span>
<span class="fc" id="L118">                    db = 1.e99;</span>
<span class="fc" id="L119">                    de = 1.e99;</span>
                } else {
<span class="nc" id="L121">                    pts.getSubmatrixAsArray(j, 0, j, endPts, p);</span>
<span class="nc" id="L122">                    db = fprime(s, p, 1, 0, 0);</span>
<span class="nc" id="L123">                    de = fprime(s, p, -1, in - 1, in - 1);</span>
                }
<span class="fc" id="L125">                pts.getSubmatrixAsArray(j, 0, j, endPts, p);</span>
<span class="fc" id="L126">                srp[j] = new CubicSplineInterpolator(s, p, db, de);</span>
            }
<span class="nc" id="L128">        } catch (final WrongSizeException e) {</span>
<span class="nc" id="L129">            throw new InterpolationException(e);</span>
<span class="fc" id="L130">        }</span>
<span class="fc" id="L131">    }</span>

    /**
     * Constructor assuming that curve is NOT closed.
     *
     * @param ptsin matrix containing points on each row. Number of columns determines number of
     *              dimensions of each point.
     * @throws InterpolationException if a numerical exception occurs.
     */
    public CurveInterpolator(final Matrix ptsin) throws InterpolationException {
<span class="fc" id="L141">        this(ptsin, false);</span>
<span class="fc" id="L142">    }</span>

    /**
     * Interpolates a point on the stored curve. The point is parameterized by t, in the range
     * [0,1].
     * For open curves, values of t outside this range will return extrapolations (dangerous!).
     * For closed curves t is periodic with period 1.
     *
     * @param t position in the curve to be interpolated.
     * @return result of interpolation.
     * @throws InterpolationException if interpolation fails for numerical reasons.
     */
    public double[] interpolate(double t) throws InterpolationException {
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (cls) {</span>
<span class="nc" id="L156">            t = t - Math.floor(t);</span>
        }

<span class="fc bfc" id="L159" title="All 2 branches covered.">        for (var j = 0; j &lt; dim; j++) {</span>
<span class="fc" id="L160">            ans[j] = srp[j].interpolate(t);</span>
        }
<span class="fc" id="L162">        return ans;</span>
    }

    /**
     * Utility for estimating the derivatives at the endpoints, x and y point to the abscissa and
     * ordinate of the endpoint. If pm is +1, points to the right will be used (left endpoint): if it
     * is -1, points to the left will be used (right endpoint).
     *
     * @param x  abscissa of endpoint.
     * @param y ordinate of endpoint.
     * @param pm +1 or -1.
     * @param xoff offset of x.
     * @param yoff offset of y.
     */
    private double fprime(final double[] x, final double[] y, final int pm, final int xoff, final int yoff) {
<span class="nc" id="L177">        final var s1 = x[xoff] - x[xoff + pm];</span>
<span class="nc" id="L178">        final var s2 = x[xoff] - x[xoff + pm * 2];</span>
<span class="nc" id="L179">        final var s3 = x[xoff] - x[xoff + pm * 3];</span>
<span class="nc" id="L180">        final var s12 = s1 - s2;</span>
<span class="nc" id="L181">        final var s13 = s1 - s3;</span>
<span class="nc" id="L182">        final var s23 = s2 - s3;</span>
<span class="nc" id="L183">        return -(s1 * s2 / (s13 * s23 * s3)) * y[yoff + pm * 3] + (s1 * s3 / (s12 * s2 * s23)) * y[yoff + pm * 2]</span>
                - (s2 * s3 / (s1 * s12 * s13)) * y[yoff + pm] + (1.0 / s1 + 1.0 / s2 + 1.0 / s3) * y[yoff];
    }

    /**
     * Computes the euclidean distance between two points.
     *
     * @param p1 first point.
     * @param p2 second point.
     * @return euclidean distance.
     */
    private double rad(final double[] p1, final double[] p2) {
<span class="fc" id="L195">        var sum = 0.0;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        for (var i = 0; i &lt; dim; i++) {</span>
<span class="fc" id="L197">            final var value = p1[i] - p2[i];</span>
<span class="fc" id="L198">            sum += value * value;</span>
        }
<span class="fc" id="L200">        return Math.sqrt(sum);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>