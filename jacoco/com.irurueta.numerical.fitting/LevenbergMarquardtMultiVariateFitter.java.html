<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LevenbergMarquardtMultiVariateFitter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-numerical</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.numerical.fitting</a> &gt; <span class="el_source">LevenbergMarquardtMultiVariateFitter.java</span></div><h1>LevenbergMarquardtMultiVariateFitter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.numerical.fitting;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.GaussJordanElimination;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.numerical.EvaluationException;
import com.irurueta.numerical.NotReadyException;
import com.irurueta.statistics.ChiSqDist;
import com.irurueta.statistics.MaxIterationsExceededException;

import java.util.Arrays;

/**
 * Fits provided data (x, y) to a generic non-linear function using
 * Levenberg-Marquardt iterative algorithm.
 * This class is based on the implementation available at Numerical Recipes 3rd
 * Ed, page 801.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class LevenbergMarquardtMultiVariateFitter extends MultiVariateFitter {

    /**
     * Default convergence parameter. Number of times that tolerance is assumed
     * to be reached to consider that algorithm has finished iterating.
     */
    public static final int DEFAULT_NDONE = 4;

    /**
     * Default maximum number of iterations.
     */
    public static final int DEFAULT_ITMAX = 5000;

    /**
     * Default tolerance to reach convergence.
     */
    public static final double DEFAULT_TOL = 1e-3;

    /**
     * Indicates whether covariance must be adjusted or not after fitting is finished.
     */
    public static final boolean DEFAULT_ADJUST_COVARIANCE = true;

    /**
     * Convergence parameter.
     */
<span class="fc" id="L62">    private int ndone = DEFAULT_NDONE;</span>

    /**
     * Maximum number of iterations.
     */
<span class="fc" id="L67">    private int itmax = DEFAULT_ITMAX;</span>

    /**
     * Tolerance to reach convergence.
     */
<span class="fc" id="L72">    private double tol = DEFAULT_TOL;</span>

    /**
     * Evaluator of functions.
     */
    private LevenbergMarquardtMultiVariateFunctionEvaluator evaluator;

    /**
     * Number of function parameters to be estimated.
     */
    private int ma;

    /**
     * Determines which parameters can be modified during estimation (if true)
     * and which ones are locked (if false).
     */
    private boolean[] ia;

    /**
     * Curvature matrix.
     */
    private Matrix alpha;

    /**
     * Number of parameters ot be fitted.
     */
<span class="fc" id="L98">    private int mfit = 0;</span>

    /**
     * An input point to be evaluated.
     */
    private double[] xRow;

    /**
     * Results of function evaluations.
     */
    private double[] ymod;

    /**
     * Jacobian of function at a given point.
     */
    Matrix jacobian;

    /**
     * Mean square error.
     */
<span class="fc" id="L118">    private double mse = 0.0;</span>

    /**
     * Indicates whether covariance must be adjusted or not.
     * When covariance adjustment is enabled, then covariance is recomputed taking
     * into account input samples, input standard deviations of the samples and
     * jacobians of the model function overestimated parameters using the following
     * expression: Cov = (J'*W*J)^-1 where:
     * Cov is the covariance of estimated parameters
     * J is a matrix containing the Jacobians of the function overestimated parameters
     * for each input parameter x. Each row of J matrix contains an evaluation of
     * the model function Jacobian for i-th input parameter x. Each column of J matrix
     * contains the partial derivative of model function over j-th estimated parameter.
     * W is the inverse of input variances. It's a diagonal matrix containing the
     * reciprocal of the input variances (squared input standard deviations). That is:
     * W = diag(w) where k element of w is wk = 1 / sigmak^2, which corresponds to
     * the k-th standard deviation of input sample k.
     * By default, covariance is adjusted after fitting finishes.
     */
<span class="fc" id="L137">    private boolean adjustCovariance = DEFAULT_ADJUST_COVARIANCE;</span>

    /**
     * Constructor.
     */
    public LevenbergMarquardtMultiVariateFitter() {
<span class="fc" id="L143">        super();</span>
<span class="fc" id="L144">    }</span>

    /**
     * Constructor.
     *
     * @param x   input points x where multivariate function f(x1, x2, ...) is
     *            evaluated.
     * @param y   result of evaluation of linear single dimensional function f(x)
     *            at provided multidimensional x points.
     * @param sig standard deviations of each pair of points (x, y).
     * @throws IllegalArgumentException if provided number of rows and arrays
     *                                  don't have the same length.
     */
    public LevenbergMarquardtMultiVariateFitter(final Matrix x, final Matrix y, final double[] sig) {
<span class="fc" id="L158">        super(x, y, sig);</span>
<span class="fc" id="L159">    }</span>

    /**
     * Constructor.
     *
     * @param x   input points x where multivariate function f(x1, x2, ...) is
     *            evaluated.
     * @param y   result of evaluation of linear single dimensional function f(x)
     *            at provided multidimensional x points.
     * @param sig standard deviation of all pair of points assuming that
     *            standard deviations are constant.
     * @throws IllegalArgumentException if provided number of rows and arrays
     *                                  don't have the same length.
     */
    public LevenbergMarquardtMultiVariateFitter(final Matrix x, final Matrix y, final double sig) {
<span class="fc" id="L174">        super(x, y, sig);</span>
<span class="fc" id="L175">    }</span>

    /**
     * Constructor.
     *
     * @param evaluator evaluator to evaluate function at provided point and
     *                  obtain the evaluation of function basis at such point.
     * @throws FittingException if evaluation fails.
     */
    public LevenbergMarquardtMultiVariateFitter(
            final LevenbergMarquardtMultiVariateFunctionEvaluator evaluator) throws FittingException {
<span class="fc" id="L186">        this();</span>
<span class="fc" id="L187">        setFunctionEvaluator(evaluator);</span>
<span class="fc" id="L188">    }</span>

    /**
     * Constructor.
     *
     * @param evaluator evaluator to evaluate multivariate function at provided
     *                  point and obtain the evaluation of function basis at such point.
     * @param x         input points x where multivariate function f(x1, x2, ...) is
     *                  evaluated.
     * @param y         result of evaluation of linear single dimensional function f(x)
     *                  at provided multidimensional x points.
     * @param sig       standard deviations of each pair of points (x, y).
     * @throws IllegalArgumentException if provided number of rows and arrays
     *                                  don't have the same length.
     * @throws FittingException         if evaluation fails.
     */
    public LevenbergMarquardtMultiVariateFitter(
            final LevenbergMarquardtMultiVariateFunctionEvaluator evaluator, final Matrix x, final Matrix y,
            final double[] sig) throws FittingException {
<span class="fc" id="L207">        this(x, y, sig);</span>
<span class="fc" id="L208">        setFunctionEvaluator(evaluator);</span>
<span class="fc" id="L209">    }</span>

    /**
     * Constructor.
     *
     * @param evaluator evaluator to evaluate multivariate function at provided
     *                  point and obtain the evaluation of function basis at such point.
     * @param x         input points x where multivariate function f(x1, x2, ...) is
     *                  evaluated.
     * @param y         result of evaluation of linear single dimensional function f(x)
     *                  at provided multidimensional x points.
     * @param sig       standard deviation of all pair of points assuming that
     *                  standard deviations are constant.
     * @throws IllegalArgumentException if provided number of rows and arrays
     *                                  don't have the same length.
     * @throws FittingException         if evaluation fails.
     */
    public LevenbergMarquardtMultiVariateFitter(
            final LevenbergMarquardtMultiVariateFunctionEvaluator evaluator, final Matrix x, final Matrix y,
            final double sig) throws FittingException {
<span class="fc" id="L229">        this(x, y, sig);</span>
<span class="fc" id="L230">        setFunctionEvaluator(evaluator);</span>
<span class="fc" id="L231">    }</span>

    /**
     * Returns convergence parameter.
     *
     * @return convergence parameter.
     */
    public int getNdone() {
<span class="fc" id="L239">        return ndone;</span>
    }

    /**
     * Sets convergence parameter.
     *
     * @param ndone convergence parameter.
     * @throws IllegalArgumentException if provided value is less than 1.
     */
    public void setNdone(final int ndone) {
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (ndone &lt; 1) {</span>
<span class="fc" id="L250">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L252">        this.ndone = ndone;</span>
<span class="fc" id="L253">    }</span>

    /**
     * Returns maximum number of iterations.
     *
     * @return maximum number of iterations.
     */
    public int getItmax() {
<span class="fc" id="L261">        return itmax;</span>
    }

    /**
     * Sets maximum number of iterations.
     *
     * @param itmax maximum number of iterations.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setItmax(final int itmax) {
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (itmax &lt;= 0) {</span>
<span class="fc" id="L272">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L274">        this.itmax = itmax;</span>
<span class="fc" id="L275">    }</span>

    /**
     * Returns tolerance to reach convergence.
     *
     * @return tolerance to reach convergence.
     */
    public double getTol() {
<span class="fc" id="L283">        return tol;</span>
    }

    /**
     * Sets tolerance to reach convergence.
     *
     * @param tol tolerance to reach convergence.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setTol(final double tol) {
<span class="fc bfc" id="L293" title="All 2 branches covered.">        if (tol &lt;= 0.0) {</span>
<span class="fc" id="L294">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L296">        this.tol = tol;</span>
<span class="fc" id="L297">    }</span>

    /**
     * Returns function evaluator to evaluate function at a given point and
     * obtain function jacobian respect to each provided parameter.
     *
     * @return function evaluator.
     */
    public LevenbergMarquardtMultiVariateFunctionEvaluator getFunctionEvaluator() {
<span class="fc" id="L306">        return evaluator;</span>
    }

    /**
     * Sets function evaluator to evaluate function at a given point and obtain
     * function jacobian respect to each provided parameter.
     *
     * @param evaluator function evaluator.
     * @throws FittingException if evaluation fails.
     */
    public final void setFunctionEvaluator(
            final LevenbergMarquardtMultiVariateFunctionEvaluator evaluator) throws FittingException {
<span class="fc" id="L318">        internalSetFunctionEvaluator(evaluator);</span>
<span class="fc" id="L319">    }</span>

    /**
     * Indicates whether provided instance has enough data to start the function
     * fitting.
     *
     * @return true if this instance is ready to start the function fitting,
     * false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="pc bpc" id="L330" title="2 of 8 branches missed.">        return evaluator != null &amp;&amp; x != null &amp;&amp; y != null &amp;&amp; x.getRows() == y.getRows()</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">                &amp;&amp; x.getColumns() == evaluator.getNumberOfDimensions()</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">                &amp;&amp; y.getColumns() == evaluator.getNumberOfVariables();</span>
    }

    /**
     * Returns curvature matrix.
     *
     * @return curvature matrix.
     */
    public Matrix getAlpha() {
<span class="fc" id="L341">        return alpha;</span>
    }

    /**
     * Returns degrees of freedom of computed chi square value.
     * Degrees of freedom is equal to the number of sampled data minus the
     * number of estimated parameters.
     *
     * @return degrees of freedom of computed chi square value.
     */
    public int getChisqDegreesOfFreedom() {
<span class="fc" id="L352">        return ndat - ma;</span>
    }

    /**
     * Gets mean square error produced by estimated parameters respect to
     * provided sample data.
     *
     * @return mean square error.
     */
    public double getMse() {
<span class="fc" id="L362">        return mse;</span>
    }

    /**
     * Gets the probability of finding a smaller chi square value.
     * The smaller the found chi square value is, the better the fit of the estimated
     * parameters to the actual parameter.
     * Thus, the smaller the chance of finding a smaller chi square value, then the
     * better the estimated fit is.
     *
     * @return probability of finding a smaller chi square value (better fit), expressed
     * as a value between 0.0 and 1.0.
     * @throws MaxIterationsExceededException if convergence of incomplete
     *                                        gamma function cannot be reached. This is rarely thrown and happens
     *                                        usually for numerically unstable input values.
     */
    public double getP() throws MaxIterationsExceededException {
<span class="fc" id="L379">        return ChiSqDist.cdf(getChisq(), getChisqDegreesOfFreedom());</span>
    }

    /**
     * Gets a measure of quality of estimated fit as a value between 0.0 and 1.0.
     * The larger the quality value is, the better the fit that has been estimated.
     *
     * @return measure of quality of estimated fit.
     * @throws MaxIterationsExceededException if convergence of incomplete
     *                                        gamma function cannot be reached. This is rarely thrown and happens
     *                                        usually for numerically unstable input values.
     */
    public double getQ() throws MaxIterationsExceededException {
<span class="fc" id="L392">        return 1.0 - getP();</span>
    }

    /**
     * Indicates whether covariance must be adjusted or not.
     * When covariance adjustment is enabled, then covariance is recomputed taking
     * into account input samples, input standard deviations of the samples and
     * jacobians of the model function overestimated parameters using the following
     * expression: Cov = (J'*W*J)^-1 where:
     * Cov is the covariance of estimated parameters
     * J is a matrix containing the Jacobians of the function overestimated parameters
     * for each input parameter x. Each row of J matrix contains an evaluation of
     * the model function Jacobian for i-th input parameter x. Each column of J matrix
     * contains the partial derivative of model function over j-th estimated parameter.
     * W is the inverse of input variances. It's a diagonal matrix containing the
     * reciprocal of the input variances (squared input standard deviations). That is:
     * W = diag(w) where k element of w is wk = 1 / sigmak^2, which corresponds to
     * the k-th standard deviation of input sample k.
     * By default, covariance is adjusted after fitting finishes.
     * &lt;a href=&quot;http://people.duke.edu/~hpgavin/ce281/lm.pdf&quot;&gt;http://people.duke.edu/~hpgavin/ce281/lm.pdf&lt;/a&gt;
     * &lt;a href=&quot;https://www8.cs.umu.se/kurser/5DA001/HT07/lectures/lsq-handouts.pdf&quot;&gt;https://www8.cs.umu.se/kurser/5DA001/HT07/lectures/lsq-handouts.pdf&lt;/a&gt;
     * Numerical Recipes 3rd Ed, page 812
     *
     * @return true if covariance must be adjusted, false otherwise.
     */
    public boolean isCovarianceAdjusted() {
<span class="fc" id="L418">        return adjustCovariance;</span>
    }

    /**
     * Specifies whether covariance must be adjusted or not.
     * When covariance adjustment is enabled, then covariance is recomputed taking
     * into account input samples, input standard deviations of the samples and
     * jacobians of the model function overestimated parameters using the following
     * expression: Cov = (J'*W*J)^-1 where:
     * Cov is the covariance of estimated parameters
     * J is a matrix containing the Jacobians of the function overestimated parameters
     * for each input parameter x. Each row of J matrix contains an evaluation of
     * the model function Jacobian for i-th input parameter x. Each column of J matrix
     * contains the partial derivative of model function over j-th estimated parameter.
     * W is the inverse of input variances. It's a diagonal matrix containing the
     * reciprocal of the input variances (squared input standard deviations). That is:
     * W = diag(w) where k element of w is wk = 1 / sigmak^2, which corresponds to
     * the k-th standard deviation of input sample k.
     * By default, covariance is adjusted after fitting finishes.
     *
     * @param adjustCovariance true if covariance must be adjusted, false otherwise.
     */
    public void setCovarianceAdjusted(final boolean adjustCovariance) {
<span class="fc" id="L441">        this.adjustCovariance = adjustCovariance;</span>
<span class="fc" id="L442">    }</span>

    /**
     * Fits a function to provided data so that parameters associated to that
     * function can be estimated along with their covariance matrix and chi
     * square value.
     * If chi square value is close to 1, the fit is usually good.
     * If it is much larger, then error cannot be properly fitted.
     * If it is close to zero, then the model over-fits the error.
     * Methods {@link #getP()} and {@link #getQ()} can also be used to determine
     * the quality of the fit.
     *
     * @throws FittingException  if fitting fails.
     * @throws NotReadyException if enough input data has not yet been provided.
     */
    @Override
    public void fit() throws FittingException, NotReadyException {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L460">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L464">            resultAvailable = false;</span>

            int j;
            int k;
            int l;
            int iter;
<span class="fc" id="L470">            int done = 0;</span>
<span class="fc" id="L471">            double alamda = 0.001;</span>
            double ochisq;
<span class="fc" id="L473">            final var atry = new double[ma];</span>
<span class="fc" id="L474">            final var beta = new double[ma];</span>
<span class="fc" id="L475">            final var da = new double[ma];</span>

            // number of parameters to be fitted
<span class="fc" id="L478">            mfit = 0;</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">            for (j = 0; j &lt; ma; j++) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                if (ia[j]) {</span>
<span class="fc" id="L481">                    mfit++;</span>
                }
            }

<span class="fc" id="L485">            final var oneda = new Matrix(mfit, 1);</span>
<span class="fc" id="L486">            final var temp = new Matrix(mfit, mfit);</span>

            // initialization
<span class="fc" id="L489">            mrqcof(a, alpha, beta);</span>
<span class="fc" id="L490">            System.arraycopy(a, 0, atry, 0, ma);</span>

<span class="fc" id="L492">            ochisq = chisq;</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">            for (iter = 0; iter &lt; itmax; iter++) {</span>

<span class="fc bfc" id="L495" title="All 2 branches covered.">                if (done == ndone) {</span>
                    // last pass. Use zero alamda
<span class="fc" id="L497">                    alamda = 0.0;</span>
                }

<span class="fc bfc" id="L500" title="All 2 branches covered.">                for (j = 0; j &lt; mfit; j++) {</span>
                    // alter linearized fitting matrix, by augmenting diagonal
                    // elements
<span class="fc bfc" id="L503" title="All 2 branches covered.">                    for (k = 0; k &lt; mfit; k++) {</span>
<span class="fc" id="L504">                        covar.setElementAt(j, k, alpha.getElementAt(j, k));</span>
                    }
<span class="fc" id="L506">                    covar.setElementAt(j, j, alpha.getElementAt(j, j) * (1.0 + alamda));</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">                    for (k = 0; k &lt; mfit; k++) {</span>
<span class="fc" id="L508">                        temp.setElementAt(j, k, covar.getElementAt(j, k));</span>
                    }
<span class="fc" id="L510">                    oneda.setElementAt(j, 0, beta[j]);</span>
                }

                // matrix solution
<span class="fc" id="L514">                GaussJordanElimination.process(temp, oneda);</span>

<span class="fc bfc" id="L516" title="All 2 branches covered.">                for (j = 0; j &lt; mfit; j++) {</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                    for (k = 0; k &lt; mfit; k++) {</span>
<span class="fc" id="L518">                        covar.setElementAt(j, k, temp.getElementAt(j, k));</span>
                    }
<span class="fc" id="L520">                    da[j] = oneda.getElementAt(j, 0);</span>
                }

<span class="fc bfc" id="L523" title="All 2 branches covered.">                if (done == ndone) {</span>
                    // Converged. Clean up and return
<span class="fc" id="L525">                    covsrt(covar);</span>
<span class="fc" id="L526">                    covsrt(alpha);</span>

<span class="fc bfc" id="L528" title="All 2 branches covered.">                    if (adjustCovariance) {</span>
<span class="fc" id="L529">                        adjustCovariance();</span>
                    }

<span class="fc" id="L532">                    resultAvailable = true;</span>

<span class="fc" id="L534">                    return;</span>
                }

                // did the trial succeed?
<span class="fc bfc" id="L538" title="All 2 branches covered.">                for (j = 0, l = 0; l &lt; ma; l++) {</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">                    if (ia[l]) {</span>
<span class="fc" id="L540">                        atry[l] = a[l] + da[j++];</span>
                    }
                }

<span class="fc" id="L544">                mrqcof(atry, covar, da);</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">                if (Math.abs(chisq - ochisq) &lt; Math.max(tol, tol * chisq)) {</span>
<span class="fc" id="L546">                    done++;</span>
                }

<span class="fc bfc" id="L549" title="All 2 branches covered.">                if (chisq &lt; ochisq) {</span>
                    // success, accept the new solution
<span class="fc" id="L551">                    alamda *= 0.1;</span>
<span class="fc" id="L552">                    ochisq = chisq;</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">                    for (j = 0; j &lt; mfit; j++) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                        for (k = 0; k &lt; mfit; k++) {</span>
<span class="fc" id="L555">                            alpha.setElementAt(j, k, covar.getElementAt(j, k));</span>
                        }
<span class="fc" id="L557">                        beta[j] = da[j];</span>
                    }
<span class="fc" id="L559">                    System.arraycopy(atry, 0, a, 0, ma);</span>
                } else {
                    // failure, increase alamda
<span class="fc" id="L562">                    alamda *= 10.0;</span>
<span class="fc" id="L563">                    chisq = ochisq;</span>
                }
            }

            // too many iterations
<span class="nc" id="L568">            throw new FittingException(&quot;too many iterations&quot;);</span>

<span class="nc" id="L570">        } catch (final AlgebraException | EvaluationException e) {</span>
<span class="nc" id="L571">            throw new FittingException(e);</span>
        }
    }

    /**
     * Prevents parameter at position i of linear combination of basis functions
     * to be modified during function fitting.
     *
     * @param i   position of parameter to be retained.
     * @param val value to be set for parameter at position i.
     */
    public void hold(final int i, final double val) {
<span class="fc" id="L583">        ia[i] = false;</span>
<span class="fc" id="L584">        a[i] = val;</span>
<span class="fc" id="L585">    }</span>

    /**
     * Releases parameter at position i of linear combination of basis functions,
     * so it can be modified again if needed.
     *
     * @param i position of parameter to be released.
     */
    public void free(final int i) {
<span class="fc" id="L594">        ia[i] = true;</span>
<span class="fc" id="L595">    }</span>

    /**
     * Adjusts covariance.
     * Covariance must be adjusted to produce more real results close to the scale
     * of problem, otherwise estimated covariance will just be a measure of
     * goodness similar to chi square value because it will be the inverse of
     * the curvature matrix, which is just a solution of the covariance up to scale.
     * &lt;p&gt;
     * Covariance is adjusted taking into account input samples, input standard
     * deviations of the samples and jacobians of the model function overestimated
     * parameters using the following expression: Cov = (J'*W*J)^-1 where:
     * Cov is the covariance of estimated parameters
     * J is a matrix containing the Jacobians of the function overestimated parameters
     * for each input parameter x. Each row of J matrix contains an evaluation of
     * the model function Jacobian for i-th input parameter x. Each column of J matrix
     * contains the partial derivative of model function over j-th estimated parameter.
     * W is the inverse of input variances. It's a diagonal matrix containing the
     * reciprocal of the input variances (squared input standard deviations). That is:
     * W = diag(w) where k element of w is wk = 1 / sigmak^2, which corresponds to
     * the k-th standard deviation of input sample k.
     *
     * @throws AlgebraException    if there are numerical instabilities.
     * @throws EvaluationException if function evaluation fails.
     */
    private void adjustCovariance() throws AlgebraException, EvaluationException {

<span class="fc" id="L622">        final var nVars = evaluator.getNumberOfVariables();</span>
<span class="fc" id="L623">        final var xCols = x.getColumns();</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">        if (xRow == null) {</span>
<span class="nc" id="L625">            xRow = new double[x.getColumns()];</span>
        }
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">        if (jacobian == null) {</span>
<span class="nc" id="L628">            jacobian = new Matrix(nVars, ma);</span>
        }

<span class="fc" id="L631">        final var jacobianTrans = new Matrix(ma, nVars);</span>

<span class="fc" id="L633">        final var invCov = new Matrix(a.length, a.length);</span>
<span class="fc" id="L634">        final var tmpInvCov = new Matrix(a.length, a.length);</span>
<span class="fc" id="L635">        final var chiSqrDegreesOfFreedom = getChisqDegreesOfFreedom();</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        for (int i = 0; i &lt; ndat; i++) {</span>
<span class="fc" id="L637">            x.getSubmatrixAsArray(i, 0, i, xCols - 1, xRow);</span>

<span class="fc" id="L639">            evaluator.evaluate(i, xRow, ymod, a, jacobian);</span>

<span class="fc" id="L641">            jacobian.transpose(jacobianTrans);</span>

<span class="fc" id="L643">            jacobianTrans.multiply(jacobian, tmpInvCov);</span>

<span class="fc" id="L645">            final var w = 1.0 / ((chiSqrDegreesOfFreedom + 1) * sig[i] * sig[i]);</span>
<span class="fc" id="L646">            tmpInvCov.multiplyByScalar(w);</span>
<span class="fc" id="L647">            invCov.add(tmpInvCov);</span>
        }

<span class="fc" id="L650">        covar = Utils.inverse(invCov);</span>
<span class="fc" id="L651">    }</span>

    /**
     * Internal method to set function evaluator to evaluate function at a given
     * point and obtain function jacobian respect to each provided parameter.
     *
     * @param evaluator function evaluator.
     * @throws FittingException if evaluation fails.
     */
    private void internalSetFunctionEvaluator(final LevenbergMarquardtMultiVariateFunctionEvaluator evaluator)
            throws FittingException {

        try {
<span class="fc" id="L664">            this.evaluator = evaluator;</span>

<span class="pc bpc" id="L666" title="1 of 2 branches missed.">            if (evaluator != null) {</span>
<span class="fc" id="L667">                a = evaluator.createInitialParametersArray();</span>
<span class="fc" id="L668">                ma = a.length;</span>
<span class="fc" id="L669">                covar = new Matrix(ma, ma);</span>
<span class="fc" id="L670">                alpha = new Matrix(ma, ma);</span>
<span class="fc" id="L671">                ia = new boolean[ma];</span>
<span class="fc" id="L672">                Arrays.fill(ia, true);</span>
            }
<span class="nc" id="L674">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L675">            throw new FittingException(e);</span>
<span class="fc" id="L676">        }</span>
<span class="fc" id="L677">    }</span>

    /**
     * Used by fit to evaluate the linearized fitting matrix alpha, and vector
     * beta to calculate chi square.
     *
     * @param a     estimated parameters so far.
     * @param alpha curvature (i.e. fitting) matrix.
     * @param beta  array where derivative increments for each parameter are
     *              stored.
     * @throws AlgebraException    if there are numerical instabilities.
     * @throws EvaluationException if function evaluation fails.
     */
    private void mrqcof(final double[] a, final Matrix alpha, final double[] beta)
            throws AlgebraException, EvaluationException {

        int i;
        int j;
        int k;
        int l;
        int m;
        double wt;
        double sig2i;
        double dy;
<span class="fc" id="L701">        final var nVars = evaluator.getNumberOfVariables();</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">        if (jacobian == null) {</span>
<span class="fc" id="L703">            jacobian = new Matrix(nVars, ma);</span>
        }
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (xRow == null) {</span>
<span class="fc" id="L706">            xRow = new double[x.getColumns()];</span>
        }
<span class="fc" id="L708">        final var xCols = evaluator.getNumberOfDimensions();</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">        if (ymod == null) {</span>
<span class="fc" id="L710">            ymod = new double[nVars];</span>
        }

<span class="fc bfc" id="L713" title="All 2 branches covered.">        for (j = 0; j &lt; mfit; j++) {</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">            for (k = 0; k &lt;= j; k++) {</span>
<span class="fc" id="L715">                alpha.setElementAt(j, k, 0.0);</span>
            }
<span class="fc" id="L717">            beta[j] = 0.;</span>
        }

<span class="fc" id="L720">        chisq = 0.0;</span>
<span class="fc" id="L721">        mse = 0.0;</span>
<span class="fc" id="L722">        final var degreesOfFreedom = getChisqDegreesOfFreedom();</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        for (i = 0; i &lt; ndat; i++) {</span>
            // summation loop over all data
<span class="fc" id="L725">            x.getSubmatrixAsArray(i, 0, i, xCols - 1, xRow);</span>
<span class="fc" id="L726">            evaluator.evaluate(i, xRow, ymod, a, jacobian);</span>
<span class="fc" id="L727">            sig2i = 1.0 / (sig[i] * sig[i]);</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">            for (int n = 0; n &lt; nVars; n++) {</span>
<span class="fc" id="L729">                dy = y.getElementAt(i, n) - ymod[n];</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">                for (j = 0, l = 0; l &lt; ma; l++) {</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">                    if (ia[l]) {</span>
<span class="fc" id="L732">                        wt = jacobian.getElementAt(n, l) * sig2i;</span>
<span class="fc" id="L733">                        final var alphaBuffer = alpha.getBuffer();</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">                        for (k = 0, m = 0; m &lt; l + 1; m++) {</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">                            if (ia[m]) {</span>
<span class="fc" id="L736">                                final var index = alpha.getIndex(j, k++);</span>
<span class="fc" id="L737">                                alphaBuffer[index] += wt * jacobian.getElementAt(n, m);</span>
                            }
                        }
<span class="fc" id="L740">                        beta[j++] += dy * wt;</span>
                    }
                }

                // add to mse
<span class="fc" id="L745">                mse += dy * dy / Math.abs(degreesOfFreedom);</span>

                // and find chi square
<span class="fc" id="L748">                chisq += dy * dy * sig2i / degreesOfFreedom;</span>
            }
        }

        // fill in the symmetric side
<span class="fc bfc" id="L753" title="All 2 branches covered.">        for (j = 1; j &lt; mfit; j++) {</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">            for (k = 0; k &lt; j; k++) {</span>
<span class="fc" id="L755">                alpha.setElementAt(k, j, alpha.getElementAt(j, k));</span>
            }
        }
<span class="fc" id="L758">    }</span>

    /**
     * Expand in storage the covariance matrix covar, to take into account
     * parameters that are being held fixed. (For the latter, return zero
     * covariances).
     *
     * @param covar covariance matrix.
     */
    private void covsrt(final Matrix covar) {
        int i;
        int j;
        int k;
<span class="fc bfc" id="L771" title="All 2 branches covered.">        for (i = mfit; i &lt; ma; i++) {</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">            for (j = 0; j &lt; i + 1; j++) {</span>
<span class="fc" id="L773">                covar.setElementAt(i, j, 0.0);</span>
<span class="fc" id="L774">                covar.setElementAt(j, i, 0.0);</span>
            }
        }

<span class="fc" id="L778">        k = mfit - 1;</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">        for (j = ma - 1; j &gt;= 0; j--) {</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">            if (ia[j]) {</span>
<span class="fc" id="L781">                final var buffer = covar.getBuffer();</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">                for (i = 0; i &lt; ma; i++) {</span>
<span class="fc" id="L783">                    final var pos1 = covar.getIndex(i, k);</span>
<span class="fc" id="L784">                    final var pos2 = covar.getIndex(i, j);</span>
<span class="fc" id="L785">                    swap(buffer, buffer, pos1, pos2);</span>
                }
<span class="fc bfc" id="L787" title="All 2 branches covered.">                for (i = 0; i &lt; ma; i++) {</span>
<span class="fc" id="L788">                    final var pos1 = covar.getIndex(k, i);</span>
<span class="fc" id="L789">                    final var pos2 = covar.getIndex(j, i);</span>
<span class="fc" id="L790">                    swap(buffer, buffer, pos1, pos2);</span>
                }

<span class="fc" id="L793">                k--;</span>
            }
        }
<span class="fc" id="L796">    }</span>

    /**
     * Swaps values of arrays at provided positions.
     *
     * @param array1 1st array.
     * @param array2 2nd array.
     * @param pos1   1st position.
     * @param pos2   2nd position.
     */
    private static void swap(final double[] array1, final double[] array2, final int pos1, final int pos2) {
<span class="fc" id="L807">        final var value1 = array1[pos1];</span>
<span class="fc" id="L808">        final var value2 = array2[pos2];</span>
<span class="fc" id="L809">        array1[pos1] = value2;</span>
<span class="fc" id="L810">        array2[pos2] = value1;</span>
<span class="fc" id="L811">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>