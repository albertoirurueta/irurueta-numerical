<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LMedSRobustEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-numerical</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.numerical.robust</a> &gt; <span class="el_source">LMedSRobustEstimator.java</span></div><h1>LMedSRobustEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.numerical.robust;

import com.irurueta.numerical.LockedException;
import com.irurueta.numerical.NotReadyException;
import com.irurueta.sorting.Sorter;

import java.util.ArrayList;
import java.util.BitSet;

/**
 * This class implements LMedS (Least Median of Squares) algorithm to robustly
 * estimate a data model.
 * LMedS is based on the idea that a given proportion of outliers exists in the
 * total amount of samples provided. This algorithm tries to iteratively find
 * the beast subset of samples picking the ones with the least median of error.
 * To determine whether a sample is an outlier or not, and the estimated error
 * for each sample, provided listener must be used.
 * Contrary to RANSAC, this algorithm does not require a fixed threshold to be
 * set to determine whether samples are inliers or not. Instead, threshold is
 * computed dynamically. Because of that LMedS typically produces results with
 * larger error than RANSAC having a similar computational cost, because samples
 * usually contain a large error. Hence, if threshold is known in advance for a
 * given estimation, RANSAC should be preferred rather than LMedS.
 * On the contrary, if it can be ensured that samples are very accurate except
 * for some outliers, then LMedS becomes much more accurate than RANSAC because
 * it typically converges to a solution with a very small threshold. However,
 * typically inlier samples tend to have certain error, and in practice LMedS
 * produces results with a similar accuracy and computational cost than RANSAC.
 *
 * @param &lt;T&gt; type of object to be estimated.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class LMedSRobustEstimator&lt;T&gt; extends RobustEstimator&lt;T&gt; {

    /**
     * Constant defining default confidence of the estimated result, which is
     * 99%. This means that with a probability of 99% estimation will be
     * accurate because chosen sub-samples will be inliers.
     */
    public static final double DEFAULT_CONFIDENCE = 0.99;

    /**
     * Default maximum allowed number of iterations.
     */
    public static final int DEFAULT_MAX_ITERATIONS = 5000;

    /**
     * Minimum allowed confidence value.
     */
    public static final double MIN_CONFIDENCE = 0.0;

    /**
     * Maximum allowed confidence value.
     */
    public static final double MAX_CONFIDENCE = 1.0;

    /**
     * Minimum allowed number of iterations.
     */
    public static final int MIN_ITERATIONS = 1;

    /**
     * Default value to be used for stop threshold. Stop threshold can be used
     * to keep the algorithm iterating in case that best threshold is not small
     * enough. Once a better solution is found yielding a threshold smaller than
     * this value, the algorithm will stop.
     */
    public static final double DEFAULT_STOP_THRESHOLD = 0.0;

    /**
     * Minimum allowed stop threshold value.
     */
    public static final double MIN_STOP_THRESHOLD = 0.0;

    /**
     * Default factor to normalize threshold to determine inliers. This factor
     * can be used to increase or lower the dynamically computed threshold so
     * that the algorithm becomes more or less accurate. The stricter the
     * threshold (lower factor), the more time the algorithm will need to
     * converge, if it can converge. By default, the factor is 1.0, which makes
     * the threshold to be computed as the median of residuals.
     */
    public static final double DEFAULT_INLIER_FACTOR = 1.0; // 1.5 would also be reasonable

    /**
     * Minimum allowed value for inlier factor.
     */
    public static final double MIN_INLER_FACTOR = 0.0;

    /**
     * Constant to estimate standard deviation of residuals based on their
     * median.
     */
    public static final double STD_CONSTANT = 1.4826;

    /**
     * Amount of confidence expressed as a value between 0 and 1.0 (which is
     * equivalent to 100%). The amount of confidence indicates the probability
     * that the estimated result is correct. Usually this value will be close
     * to 1.0, but not exactly 1.0.
     */
    private double confidence;

    /**
     * Maximum allowed number of iterations. When the maximum number of
     * iterations is exceeded, result will not be available, however an
     * approximate result will be available for retrieval.
     */
    private int maxIterations;

    /**
     * Instance in charge of picking random subsets of samples.
     */
    private SubsetSelector subsetSelector;

    /**
     * Number of iterations to be done to obtain required confidence.
     */
    private int iters;

    /**
     * Best solution that has been found so far during an estimation.
     */
    private T bestResult;

    /**
     * Data related to inliers found for best result.
     */
    private LMedSInliersData bestInliersData;

    /**
     * Threshold to be used to keep the algorithm iterating in case that
     * best threshold is not small enough. Once a better solution is found
     * yielding a threshold smaller than this value, the algorithm will stop.
     */
    private double stopThreshold;

    /**
     * Factor to normalize threshold to determine inliers. This factor can be
     * used to increase or lower the dynamically computed threshold so that the
     * algorithm becomes more or less accurate. The stricter the threshold
     * (lower factor), the more time the algorithm will need to converge, if
     * it can converge. By default, the factor is 1.0, which makes the threshold
     * to be computed as the median of residuals.
     */
    private double inlierFactor;


    /**
     * Constructor.
     */
    public LMedSRobustEstimator() {
<span class="fc" id="L168">        super();</span>
<span class="fc" id="L169">        confidence = DEFAULT_CONFIDENCE;</span>
<span class="fc" id="L170">        maxIterations = DEFAULT_MAX_ITERATIONS;</span>
<span class="fc" id="L171">        iters = maxIterations;</span>
<span class="fc" id="L172">        bestResult = null;</span>
<span class="fc" id="L173">        bestInliersData = null;</span>
<span class="fc" id="L174">        stopThreshold = DEFAULT_STOP_THRESHOLD;</span>
<span class="fc" id="L175">        inlierFactor = DEFAULT_INLIER_FACTOR;</span>
<span class="fc" id="L176">    }</span>

    /**
     * Constructor with listener.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or its progress significantly changes, as well as in charge
     *                 of picking samples and doing per-iteration estimations.
     */
    public LMedSRobustEstimator(final LMedSRobustEstimatorListener&lt;T&gt; listener) {
<span class="fc" id="L186">        super(listener);</span>
<span class="fc" id="L187">        confidence = DEFAULT_CONFIDENCE;</span>
<span class="fc" id="L188">        maxIterations = DEFAULT_MAX_ITERATIONS;</span>
<span class="fc" id="L189">        iters = maxIterations;</span>
<span class="fc" id="L190">        bestResult = null;</span>
<span class="fc" id="L191">        bestInliersData = null;</span>
<span class="fc" id="L192">        stopThreshold = DEFAULT_STOP_THRESHOLD;</span>
<span class="fc" id="L193">        inlierFactor = DEFAULT_INLIER_FACTOR;</span>
<span class="fc" id="L194">    }</span>

    /**
     * Returns amount of confidence expressed as a value between 0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
<span class="fc" id="L205">        return confidence;</span>
    }

    /**
     * Sets amount of confidence expressed as a value between 0 and 1.0 (which
     * is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setConfidence(final double confidence) throws LockedException {
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L222">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L224" title="All 4 branches covered.">        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {</span>
<span class="fc" id="L225">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L227">        this.confidence = confidence;</span>
<span class="fc" id="L228">    }</span>

    /**
     * Maximum allowed number of iterations. When the maximum number of
     * iterations is exceeded, result will not be available, however an
     * approximate result will be available for retrieval.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
<span class="fc" id="L238">        return maxIterations;</span>
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of
     * iterations is exceeded, result will not be available, however an
     * approximate result will be available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setMaxIterations(final int maxIterations) throws LockedException {
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L253">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (maxIterations &lt; MIN_ITERATIONS) {</span>
<span class="fc" id="L256">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L258">        this.maxIterations = maxIterations;</span>
<span class="fc" id="L259">    }</span>

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best threshold is not small enough. Once a better solution is found
     * yielding a threshold smaller than this value, the algorithm will stop.
     *
     * @return threshold to be used to keep the algorithm iterating in case that
     * best threshold is not small enough.
     */
    public double getStopThreshold() {
<span class="fc" id="L270">        return stopThreshold;</span>
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best threshold is not small enough. Once a better solution is found
     * yielding a threshold smaller than this vlaue, the algorithm will stop.
     *
     * @param stopThreshold threshold to be used to keep the algorithm iterating
     *                      in case that best threshold is not small enough.
     * @throws IllegalArgumentException if provided value is less or equal than
     *                                  0.0.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L287">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (stopThreshold &lt; MIN_STOP_THRESHOLD) {</span>
<span class="fc" id="L290">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L293">        this.stopThreshold = stopThreshold;</span>
<span class="fc" id="L294">    }</span>

    /**
     * Returns factor to normalize or adjust threshold to determine inliers.
     * This factor can be used to increase or lower the dynamically computed
     * threshold so that the algorithm becomes more or less accurate. The
     * stricter the threshold (lower factor), the more time the algorithm will
     * need to converge, if it can converge. By default, the factor is 1.0, which
     * makes the threshold to be computed as the median of residuals.
     *
     * @return factor to normalize threshold to determine inliers.
     */
    public double getInlierFactor() {
<span class="fc" id="L307">        return inlierFactor;</span>
    }

    /**
     * Sets factor to normalize or adjust threshold to determine inliers.
     * This factor can be used to increase or lower the dynamically computed
     * threshold so that the algorithm becomes more or less accurate. The
     * stricter the threshold (lower factor), the more time the algorithm will
     * need to converge, if it can converge. By default, the factor is 1.0, which
     * makes the threshold to be computed as the median of residuals.
     *
     * @param inlierFactor inlier factor to be set.
     * @throws IllegalArgumentException if provided value is less or equal than
     *                                  0.0.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setInlierFactor(final double inlierFactor) throws LockedException {
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L326">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (inlierFactor &lt;= MIN_INLER_FACTOR) {</span>
<span class="fc" id="L329">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L332">        this.inlierFactor = inlierFactor;</span>
<span class="fc" id="L333">    }</span>

    /**
     * Returns number of iterations to be done to obtain required confidence.
     *
     * @return number of iterations to be done to obtain required confidence.
     */
    public int getNIters() {
<span class="fc" id="L341">        return iters;</span>
    }

    /**
     * Returns best solution that has been found so far during an estimation.
     *
     * @return best solution that has been found so far during an estimation.
     */
    public T getBestResult() {
<span class="fc" id="L350">        return bestResult;</span>
    }

    /**
     * Returns data related to inliers found for best result.
     *
     * @return data related to inliers found for best result.
     */
    public LMedSInliersData getBestInliersData() {
<span class="fc" id="L359">        return bestInliersData;</span>
    }

    /**
     * Indicates if estimator is ready to start the estimation process.
     *
     * @return true if ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (!super.isReady()) {</span>
<span class="fc" id="L370">            return false;</span>
        }
<span class="fc" id="L372">        return (listener instanceof LMedSRobustEstimatorListener);</span>
    }

    /**
     * Robustly estimates an instance of T.
     *
     * @return estimated object.
     * @throws LockedException          if robust estimator is locked.
     * @throws NotReadyException        if provided input data is not enough to start
     *                                  the estimation.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public T estimate() throws LockedException, NotReadyException, RobustEstimatorException {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L388">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L391">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L395">            final var listener = (LMedSRobustEstimatorListener&lt;T&gt;) this.listener;</span>

<span class="fc" id="L397">            locked = true;</span>

<span class="fc" id="L399">            listener.onEstimateStart(this);</span>

<span class="fc" id="L401">            final var totalSamples = listener.getTotalSamples();</span>
<span class="fc" id="L402">            final var subsetSize = listener.getSubsetSize();</span>
            int bestNumInliers;
<span class="fc" id="L404">            var threshold = Double.MAX_VALUE;</span>
<span class="fc" id="L405">            iters = Integer.MAX_VALUE;</span>
            int newNIters;
<span class="fc" id="L407">            var currentIter = 0;</span>
            // reusable list that will contain preliminary solutions on each
            // iteration
<span class="fc" id="L410">            final var iterResults = new ArrayList&lt;T&gt;();</span>
<span class="fc" id="L411">            bestResult = null; // best result found so far</span>
            // progress and previous progress to determine when progress
            // notification must occur
<span class="fc" id="L414">            var previousProgress = 0.0f;</span>
            float progress;
            // indices of subset picked in one iteration
<span class="fc" id="L417">            final var subsetIndices = new int[subsetSize];</span>
<span class="fc" id="L418">            final var residualsTemp = new double[totalSamples];</span>
            // indicates if result improved
            boolean improved;
            // indicates whether algorithm must continue iterating
<span class="fc" id="L422">            var continueIteration = true;</span>

<span class="pc bpc" id="L424" title="1 of 2 branches missed.">            if (subsetSelector == null) {</span>
                // create new subset selector
<span class="fc" id="L426">                subsetSelector = SubsetSelector.create(totalSamples);</span>
            } else {
                // set number of samples to current subset selector
<span class="nc" id="L429">                subsetSelector.setNumSamples(totalSamples);</span>
            }

            // data related to inliers
<span class="fc" id="L433">            var inliersData = new LMedSInliersData(totalSamples);</span>
            // sorter to compute medians
<span class="fc" id="L435">            final var sorter = Sorter.&lt;Double&gt;create();</span>

<span class="fc bfc" id="L437" title="All 2 branches covered.">            while (continueIteration) {</span>
                // generate a random subset of samples
<span class="fc" id="L439">                subsetSelector.computeRandomSubsets(subsetSize, subsetIndices);</span>

                // clear list of preliminary solutions before calling listener
<span class="fc" id="L442">                iterResults.clear();</span>
                // compute solution for current iteration
<span class="fc" id="L444">                listener.estimatePreliminarSolutions(subsetIndices, iterResults);</span>

                // iterate over all solutions that have been found
<span class="fc" id="L447">                improved = false;</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                for (final var iterResult : iterResults) {</span>
                    // compute inliers
<span class="fc" id="L450">                    computeInliers(iterResult, subsetSize, inlierFactor, residualsTemp, listener, sorter, inliersData);</span>

                    // save solution that produces the best residual
<span class="fc bfc" id="L453" title="All 2 branches covered.">                    if (inliersData.isMedianResidualImproved()) {</span>
<span class="fc" id="L454">                        improved = true;</span>

                        // keep current solution
<span class="fc" id="L457">                        bestResult = iterResult;</span>

                        // keep the best inliers data corresponding to best solution,
                        // in case it can be useful along with the result
<span class="fc" id="L461">                        bestInliersData = inliersData;</span>

                        // recompute number of times the algorithm needs to be
                        // executed depending on current number of inliers to
                        // achieve with probability mConfidence that we have
                        // inliers and probability 1 - mConfidence that we have
                        // outliers
<span class="fc" id="L468">                        bestNumInliers = inliersData.getNumInliers();</span>
<span class="fc" id="L469">                        final var probInlier = ((double) bestNumInliers) / ((double) totalSamples);</span>

<span class="fc" id="L471">                        final var probSubsetAllInliers = Math.pow(probInlier, subsetSize);</span>

<span class="pc bpc" id="L473" title="2 of 4 branches missed.">                        if (Math.abs(probSubsetAllInliers) &lt; Double.MIN_VALUE || Double.isNaN(probSubsetAllInliers)) {</span>
<span class="nc" id="L474">                            newNIters = Integer.MAX_VALUE;</span>
                        } else {
<span class="fc" id="L476">                            final var logProbSomeOutliers = Math.log(1.0 - probSubsetAllInliers);</span>
<span class="pc bpc" id="L477" title="2 of 4 branches missed.">                            if (Math.abs(logProbSomeOutliers) &lt; Double.MIN_VALUE || Double.isNaN(logProbSomeOutliers)) {</span>
<span class="nc" id="L478">                                newNIters = Integer.MAX_VALUE;</span>
                            } else {
<span class="fc" id="L480">                                newNIters = (int) Math.ceil(Math.abs(Math.log(1.0 - confidence) / logProbSomeOutliers));</span>
                            }
                        }

<span class="fc bfc" id="L484" title="All 2 branches covered.">                        if (newNIters &lt; iters) {</span>
<span class="fc" id="L485">                            iters = newNIters;</span>
                        }

<span class="fc" id="L488">                        threshold = inliersData.getEstimatedThreshold();</span>

                        // create new inliers data instance until a new best
                        // solution is found
<span class="fc" id="L492">                        final var bestMedianResidual = inliersData.getBestMedianResidual();</span>
<span class="fc" id="L493">                        inliersData = new LMedSInliersData(totalSamples);</span>
                        // update the best median residual on new instance so
                        // that only better solutions that are found later
                        // can update inliers data
<span class="fc" id="L497">                        inliersData.update(bestMedianResidual, inliersData.getStandardDeviation(),</span>
<span class="fc" id="L498">                                inliersData.getInliers(), inliersData.getResiduals(), inliersData.getNumInliers(),</span>
<span class="fc" id="L499">                                inliersData.getEstimatedThreshold(), false);</span>
                    }
<span class="fc" id="L501">                }</span>

<span class="pc bpc" id="L503" title="1 of 2 branches missed.">                if (iters &gt; 0) {</span>
<span class="fc" id="L504">                    progress = Math.min((float) currentIter / (float) iters, 1.0f);</span>
                } else {
<span class="nc" id="L506">                    progress = 1.0f;</span>
                }
<span class="fc bfc" id="L508" title="All 2 branches covered.">                if (progress - previousProgress &gt; progressDelta) {</span>
<span class="fc" id="L509">                    previousProgress = progress;</span>
<span class="fc" id="L510">                    listener.onEstimateProgressChange(this, progress);</span>
                }
<span class="fc" id="L512">                currentIter++;</span>
<span class="pc bpc" id="L513" title="1 of 4 branches missed.">                continueIteration = (currentIter &lt; maxIterations) &amp;&amp; (threshold &gt; stopThreshold);</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">                if (!improved) {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">                    continueIteration &amp;= (currentIter &lt; iters);</span>
                }

<span class="fc" id="L518">                listener.onEstimateNextIteration(this, currentIter);</span>
            }

            // no solution could be found after completing all iterations
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">            if (bestResult == null) {</span>
<span class="nc" id="L523">                throw new RobustEstimatorException();</span>
            }

<span class="fc" id="L526">            listener.onEstimateEnd(this);</span>

<span class="fc" id="L528">            return bestResult;</span>
<span class="nc" id="L529">        } catch (final SubsetSelectorException e) {</span>
<span class="nc" id="L530">            throw new RobustEstimatorException(e);</span>
        } finally {
<span class="fc" id="L532">            locked = false;</span>
        }
    }

    /**
     * Returns data about inliers once estimation has been done.
     *
     * @return data about inliers or null if estimation has not been done.
     */
    @Override
    public InliersData getInliersData() {
<span class="fc" id="L543">        return getBestInliersData();</span>
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
<span class="fc" id="L553">        return RobustEstimatorMethod.LMEDS;</span>
    }

    /**
     * Computes inliers data for current iteration.
     *
     * @param &lt;T&gt;           type of result to be estimated.
     * @param iterResult    result to be tested on current iteration.
     * @param subsetSize    subset sample size to be picked on each iteration.
     * @param inlierFactor  factor to adjust threshold to determine whether
     *                      samples are inliers or not.
     * @param residualsTemp temporal array to store residuals, since median
     *                      computation requires modifying the original array.
     * @param listener      listener to obtain residuals for samples.
     * @param sorter        sorter instance to compute median of residuals.
     * @param inliersData   inliers data to be reused on each iteration.
     */
    private static &lt;T&gt; void computeInliers(
            final T iterResult, final int subsetSize, final double inlierFactor, final double[] residualsTemp,
            final LMedSRobustEstimatorListener&lt;T&gt; listener, final Sorter&lt;Double&gt; sorter, LMedSInliersData inliersData) {

<span class="fc" id="L574">        final var residuals = inliersData.getResiduals();</span>
<span class="fc" id="L575">        final var inliers = inliersData.getInliers();</span>
<span class="fc" id="L576">        var bestMedianResidual = inliersData.getBestMedianResidual();</span>
<span class="fc" id="L577">        var medianResidualImproved = false;</span>

<span class="fc" id="L579">        final var totalSamples = residuals.length;</span>

<span class="fc bfc" id="L581" title="All 2 branches covered.">        for (var i = 0; i &lt; totalSamples; i++) {</span>
<span class="fc" id="L582">            residuals[i] = Math.abs(listener.computeResidual(iterResult, i));</span>
        }
<span class="fc" id="L584">        System.arraycopy(residuals, 0, residualsTemp, 0, residuals.length);</span>
<span class="fc" id="L585">        final var medianResidual = sorter.median(residualsTemp);</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">        if (medianResidual &lt; bestMedianResidual) {</span>
<span class="fc" id="L587">            bestMedianResidual = medianResidual;</span>
<span class="fc" id="L588">            medianResidualImproved = true;</span>
        }

<span class="fc" id="L591">        final var standardDeviation = STD_CONSTANT * (1.0 + 5.0 / (totalSamples - subsetSize))</span>
<span class="fc" id="L592">                * Math.sqrt(medianResidual);</span>
<span class="fc" id="L593">        final var normEstimatedThreshold = inlierFactor * medianResidual;</span>

        // determine which points are inliers
<span class="fc" id="L596">        var numInliers = 0;</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">        for (var i = 0; i &lt; totalSamples; i++) {</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">            if (residuals[i] &lt;= normEstimatedThreshold) {</span>
<span class="fc" id="L599">                numInliers++;</span>
<span class="fc" id="L600">                inliers.set(i);</span>
            } else {
<span class="fc" id="L602">                inliers.clear(i);</span>
            }
        }

        // store values in inliers data, only if residuals improve
<span class="fc bfc" id="L607" title="All 2 branches covered.">        if (medianResidualImproved) {</span>
<span class="fc" id="L608">            inliersData.update(bestMedianResidual, standardDeviation, inliers, residuals, numInliers,</span>
                    normEstimatedThreshold, true);
        }
<span class="fc" id="L611">    }</span>

    /**
     * Contains data related to inliers estimated in one iteration.
     */
    public static class LMedSInliersData extends InliersData {
        /**
         * Best median of error found so far taking into account all provided
         * samples.
         */
        private double bestMedianResidual;

        /**
         * Standard deviation of error among all provided samples respect to
         * currently estimated result.
         */
        private double standardDeviation;

        /**
         * Efficiently stores which samples are considered inliers and which
         * ones aren't.
         */
        private BitSet inliers;

        /**
         * Estimated threshold to determine whether samples are inliers or not.
         */
        private double estimatedThreshold;

        /**
         * Indicates whether median residual computed in current iteration has
         * improved respect to previous iterations.
         */
        private boolean medianResidualImproved;

        /**
         * Constructor.
         *
         * @param totalSamples total number of samples.
         */
<span class="fc" id="L651">        protected LMedSInliersData(final int totalSamples) {</span>
<span class="fc" id="L652">            bestMedianResidual = Double.MAX_VALUE;</span>
<span class="fc" id="L653">            standardDeviation = Double.MAX_VALUE;</span>
<span class="fc" id="L654">            estimatedThreshold = Double.MAX_VALUE;</span>
<span class="fc" id="L655">            inliers = new BitSet(totalSamples);</span>
<span class="fc" id="L656">            residuals = new double[totalSamples];</span>
<span class="fc" id="L657">            numInliers = 0;</span>
<span class="fc" id="L658">            medianResidualImproved = false;</span>
<span class="fc" id="L659">        }</span>

        /**
         * Returns best median of error found so far taking into account all
         * provided samples.
         *
         * @return best median of error found so far taking into account all
         * provided samples.
         */
        public double getBestMedianResidual() {
<span class="fc" id="L669">            return bestMedianResidual;</span>
        }

        /**
         * Returns standard deviation of error among all provided samples
         * respect to currently estimated result.
         *
         * @return standard deviation of error among all provided samples
         * respect to currently estimated result.
         */
        public double getStandardDeviation() {
<span class="fc" id="L680">            return standardDeviation;</span>
        }

        /**
         * Returns efficient array indicating which samples are considered
         * inliers and which ones aren't.
         *
         * @return array indicating which samples are considered inliers and
         * which ones aren't.
         */
        @Override
        public BitSet getInliers() {
<span class="fc" id="L692">            return inliers;</span>
        }

        /**
         * Returns estimated threshold to determine whether samples are inliers
         * or not.
         *
         * @return estimated threshold to determine whether samples are inliers
         * or not.
         */
        public double getEstimatedThreshold() {
<span class="fc" id="L703">            return estimatedThreshold;</span>
        }

        /**
         * Returns boolean indicating whether median residual computed in
         * current iteration has improved respect to previous iterations.
         *
         * @return true if median residual improved, false otherwise.
         */
        public boolean isMedianResidualImproved() {
<span class="fc" id="L713">            return medianResidualImproved;</span>
        }

        /**
         * Updates data contained in this instance.
         *
         * @param bestMedianResidual     best median of error found so far taking
         *                               into account all provided samples.
         * @param standardDeviation      standard deviation of error among all
         *                               provided samples respect to currently estimated result.
         * @param inliers                efficiently stores which samples are considered
         *                               inliers and which ones aren't.
         * @param residuals              residuals obtained for each sample of data.
         * @param numInliers             number of inliers found on current iteration.
         * @param estimatedThreshold     estimated threshold to determine whether
         *                               samples are inliers or not.
         * @param medianResidualImproved indicates whether median residual
         *                               computed in current iteration has improved respect to previous
         *                               iteration.
         */
        protected void update(final double bestMedianResidual, final double standardDeviation,
                              final BitSet inliers, final double[] residuals, final int numInliers,
                              final double estimatedThreshold, final boolean medianResidualImproved) {
<span class="fc" id="L736">            this.bestMedianResidual = bestMedianResidual;</span>
<span class="fc" id="L737">            this.standardDeviation = standardDeviation;</span>
<span class="fc" id="L738">            this.inliers = inliers;</span>
<span class="fc" id="L739">            this.residuals = residuals;</span>
<span class="fc" id="L740">            this.numInliers = numInliers;</span>
<span class="fc" id="L741">            this.estimatedThreshold = estimatedThreshold;</span>
<span class="fc" id="L742">            this.medianResidualImproved = medianResidualImproved;</span>
<span class="fc" id="L743">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>