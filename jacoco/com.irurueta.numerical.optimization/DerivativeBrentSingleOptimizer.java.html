<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DerivativeBrentSingleOptimizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-numerical</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.numerical.optimization</a> &gt; <span class="el_source">DerivativeBrentSingleOptimizer.java</span></div><h1>DerivativeBrentSingleOptimizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.numerical.optimization;

import com.irurueta.numerical.EvaluationException;
import com.irurueta.numerical.InvalidBracketRangeException;
import com.irurueta.numerical.LockedException;
import com.irurueta.numerical.NotAvailableException;
import com.irurueta.numerical.NotReadyException;
import com.irurueta.numerical.SingleDimensionFunctionEvaluatorListener;

/**
 * Class to compute local minimum on single dimension functions using a
 * modification of Brent's algorithm that takes into account the function's
 * derivative.
 * This class will search for a local minimum within a bracket of values.
 * A bracket is a set of points: &quot;a&quot; a minimum evaluation point,
 * &quot;b&quot; a middle evaluation point and &quot;c&quot; a maximum evaluation where a &amp;lt;= b
 * &amp;lt;= c, and where f(b) &amp;lt;= f(a) and f(b) &amp;lt;= f(c).
 * This class is based on the implementation of Numerical Recipes 3rd ed.
 * Section 10.4. Page 500.
 */
public class DerivativeBrentSingleOptimizer extends BracketedSingleOptimizer {

    /**
     * Maximum number of iterations to perform. If convergence is not found
     * within this number of iterations, the minimum search will be considered
     * as failed.
     */
    public static final int ITMAX = 100;

    /**
     * Constant defining machine precision.
     */
    public static final double ZEPS = 1e-8;

    /**
     * Default tolerance. Estimated result will be found with an accuracy below
     * or equal to provided tolerance value.
     */
    public static final double DEFAULT_TOLERANCE = 3e-8;

    /**
     * Minimum allowed tolerance value.
     */
    public static final double MIN_TOLERANCE = 0.0;

    /**
     * Listener to evaluate the functions derivative. If the function's
     * derivative is not know (e.g. does not have a closed expression), then
     * a DerivativeEstimator might be used inside the listener implementation.
     */
    private SingleDimensionFunctionEvaluatorListener derivativeListener;

    /**
     * Tolerance. Estimated result will be found with an accuracy below or equal
     * to provided tolerance value.
     */
    private double tolerance;

    /**
     * Empty constructor.
     */
    protected DerivativeBrentSingleOptimizer() {
<span class="fc" id="L78">        super();</span>
<span class="fc" id="L79">        tolerance = DEFAULT_TOLERANCE;</span>
<span class="fc" id="L80">    }</span>

    /**
     * Constructor. Creates an instance with provided bracket of values and a
     * listener to get single dimension function evaluations.
     *
     * @param listener           Listener to evaluate a function.
     * @param derivativeListener Listener to get function derivative.
     * @param minEvalPoint       Minimum bracket evaluation point.
     * @param middleEvalPoint    Middle bracket evaluation point.
     * @param maxEvalPoint       Maximum bracket evaluation point.
     * @param tolerance          tolerance to find result with. Estimated result will be
     *                           found with an accuracy below or equal to provided tolerance value.
     * @throws InvalidBracketRangeException Raised if the following condition is
     *                                      not met: minEvalPoint &amp;lt;= middleEvalPoint &amp;lt;= maxEvalPoint.
     * @throws IllegalArgumentException     Raised if tolerance is negative.
     */
    protected DerivativeBrentSingleOptimizer(
            final SingleDimensionFunctionEvaluatorListener listener,
            final SingleDimensionFunctionEvaluatorListener derivativeListener, final double minEvalPoint,
            final double middleEvalPoint, final double maxEvalPoint, final double tolerance)
            throws InvalidBracketRangeException {
<span class="fc" id="L102">        super(listener, minEvalPoint, middleEvalPoint, maxEvalPoint);</span>
<span class="fc" id="L103">        this.derivativeListener = derivativeListener;</span>
<span class="fc" id="L104">        internalSetTolerance(tolerance);</span>
<span class="fc" id="L105">    }</span>

    /**
     * Returns derivative listener to get function derivative.
     *
     * @return Derivative listener.
     * @throws NotAvailableException Raised if derivative listener is not
     *                               available for retrieval.
     */
    public SingleDimensionFunctionEvaluatorListener getDerivativeListener() throws NotAvailableException {
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (!isDerivativeListenerAvailable()) {</span>
<span class="fc" id="L116">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L118">        return derivativeListener;</span>
    }

    /**
     * Sets derivative listener that gets function derivative.
     *
     * @param derivativeListener Sets derivative listener.
     * @throws LockedException Raised if this instance is locked.
     */
    public void setDerivativeListener(final SingleDimensionFunctionEvaluatorListener derivativeListener)
            throws LockedException {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L130">            throw new LockedException();</span>
        }
<span class="fc" id="L132">        this.derivativeListener = derivativeListener;</span>
<span class="fc" id="L133">    }</span>

    /**
     * Returns boolean indicating whether derivative listener has been provided
     * and is available for retrieval.
     *
     * @return Boolean indicating whether derivative listener is available.
     */
    public boolean isDerivativeListenerAvailable() {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        return derivativeListener != null;</span>
    }

    /**
     * Returns tolerance value. Estimated result will be found with an accuracy
     * below or equal to provided tolerance value.
     *
     * @return Tolerance value.
     */
    public double getTolerance() {
<span class="fc" id="L152">        return tolerance;</span>
    }

    /**
     * Sets tolerance value. Estimated result will be found with an accuracy
     * below or equal to provided tolerance value.
     *
     * @param tolerance Tolerance value.
     * @throws LockedException          Raised if this instance is locked.
     * @throws IllegalArgumentException Raised if tolerance is negative.
     */
    public void setTolerance(final double tolerance) throws LockedException {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L165">            throw new LockedException();</span>
        }
<span class="fc" id="L167">        internalSetTolerance(tolerance);</span>
<span class="fc" id="L168">    }</span>

    /**
     * This function estimates a function minimum within provided or computed
     * bracket of values.
     * Given a function f that computes a function and also its derivative
     * function df, and given a bracketing triplet of abscissas &quot;ax&quot;, &quot;bx&quot;, &quot;cx&quot; (such
     * that bx is between ax and cx, and f(bx) is less than both f(ax) and
     * f(cx), this routine isolates the minimum to a fractional precision of
     * about tolerance using a modification of Brent's method that uses
     * derivatives. The abscissa of the minimum is returned as &quot;xmin&quot; and the
     * minimum function value is returned as &quot;fmin&quot;.
     *
     * @throws LockedException       Raised if this instance is locked, because
     *                               estimation is being computed.
     * @throws NotReadyException     Raised if this instance is not ready because
     *                               either a listener or a bracket has not yet been provided or computed.
     * @throws OptimizationException Raised if the algorithm failed because of
     *                               lack of convergence or because function couldn't be evaluated.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public void minimize() throws LockedException, NotReadyException, OptimizationException {
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L192">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L195">            throw new NotReadyException();</span>
        }

<span class="fc" id="L198">        locked = true;</span>

<span class="fc" id="L200">        final var v1 = new double[1];</span>
<span class="fc" id="L201">        final var v2 = new double[2];</span>
<span class="fc" id="L202">        final var v3 = new double[3];</span>

        try {
            // Will be used as flags for whether proposed steps are acceptable or
            // not
            boolean ok1;
            boolean ok2;
            double a;
            double b;
<span class="fc" id="L211">            var d = 0.0;</span>
            double d1;
            double d2;
            double du;
            double dv;
            double dw;
            double dx;
<span class="fc" id="L218">            var e = 0.0;</span>
            double fu;
            double fv;
            double fw;
            double fx;
            double olde;
            double tol1;
            double tol2;
            double u;
            double u1;
            double u2;
            double v;
            double w;
            double x;
            double xm;

            // Comments following will point out only differences from the Brent
            // single optimizer. Read that routine first.
<span class="fc" id="L236">            a = Math.min(ax, cx);</span>
<span class="fc" id="L237">            b = Math.max(ax, cx);</span>
<span class="fc" id="L238">            x = w = v = bx;</span>
<span class="fc" id="L239">            fw = fv = fx = listener.evaluate(x);</span>
<span class="fc" id="L240">            dw = dv = dx = derivativeListener.evaluate(x);</span>

            // All out housekeeping chores are doubled by the necessity of moving
            // around derivative values as well as function values
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">            for (var iter = 0; iter &lt; ITMAX; iter++) {</span>
<span class="fc" id="L245">                xm = 0.5 * (a + b);</span>
<span class="fc" id="L246">                tol1 = tolerance * Math.abs(x) + ZEPS;</span>
<span class="fc" id="L247">                tol2 = 2.0 * tol1;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                if (Math.abs(x - xm) &lt;= (tol2 - 0.5 * (b - a))) {</span>
<span class="fc" id="L249">                    fmin = fx;</span>
<span class="fc" id="L250">                    xmin = x;</span>

<span class="fc" id="L252">                    resultAvailable = true;</span>
<span class="fc" id="L253">                    locked = false;</span>
<span class="fc" id="L254">                    return;</span>
                }

<span class="fc bfc" id="L257" title="All 2 branches covered.">                final var tmp = dx &gt;= 0.0 ? a - x : b - x;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">                if (Math.abs(e) &gt; tol1) {</span>
                    // Initialize these d's to an out-of-bracket value
<span class="fc" id="L260">                    d1 = 2.0 * (b - a);</span>
<span class="fc" id="L261">                    d2 = d1;</span>
                    // Secant method with one point
<span class="fc bfc" id="L263" title="All 2 branches covered.">                    if (dw != dx) {</span>
<span class="fc" id="L264">                        d1 = (w - x) * dx / (dx - dw);</span>
                    }
                    // And the other
<span class="fc bfc" id="L267" title="All 2 branches covered.">                    if (dv != dx) {</span>
<span class="fc" id="L268">                        d2 = (v - x) * dx / (dx - dv);</span>
                    }
                    // Which of these two estimates of d shall we take? We will
                    // insist that they be within the bracket, and on the side
                    // pointed to by the derivative at x
<span class="fc" id="L273">                    u1 = x + d1;</span>
<span class="fc" id="L274">                    u2 = x + d2;</span>
<span class="pc bpc" id="L275" title="1 of 4 branches missed.">                    ok1 = (a - u1) * (u1 - b) &gt; 0.0 &amp;&amp; dx * d1 &lt;= 0.0;</span>
<span class="fc bfc" id="L276" title="All 4 branches covered.">                    ok2 = (a - u2) * (u2 - b) &gt; 0.0 &amp;&amp; dx * d2 &lt;= 0.0;</span>
                    // Movement on the step before last
<span class="fc" id="L278">                    olde = e;</span>
<span class="fc" id="L279">                    e = d;</span>
<span class="fc bfc" id="L280" title="All 4 branches covered.">                    if (ok1 || ok2) {</span>
                        // Take only an acceptable d, and if both are acceptable,
                        // then take the smallest one.
<span class="fc bfc" id="L283" title="All 4 branches covered.">                        if (ok1 &amp;&amp; ok2) {</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                            d = Math.abs(d1) &lt; Math.abs(d2) ? d1 : d2;</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">                        } else if (ok1) {</span>
<span class="fc" id="L286">                            d = d1;</span>
                        } else {
<span class="fc" id="L288">                            d = d2;</span>
                        }

<span class="fc bfc" id="L291" title="All 2 branches covered.">                        if (Math.abs(d) &lt;= Math.abs(0.5 * olde)) {</span>
<span class="fc" id="L292">                            u = x + d;</span>
<span class="fc bfc" id="L293" title="All 4 branches covered.">                            if (u - a &lt; tol2 || b - u &lt; tol2) {</span>
<span class="fc" id="L294">                                d = sign(tol1, xm - x);</span>
                            }
                        } else {
                            // Bisect, not golden section.
<span class="fc" id="L298">                            e = tmp;</span>
<span class="fc" id="L299">                            d = 0.5 * (e);</span>
                            // Decide which segment by the sign of the derivative
                        }
                    } else {
<span class="fc" id="L303">                        e = tmp;</span>
<span class="fc" id="L304">                        d = 0.5 * e;</span>
                    }
                } else {
<span class="fc" id="L307">                    e = tmp;</span>
<span class="fc" id="L308">                    d = 0.5 * e;</span>
                }

<span class="fc bfc" id="L311" title="All 2 branches covered.">                if (Math.abs(d) &gt;= tol1) {</span>
<span class="fc" id="L312">                    u = x + d;</span>
<span class="fc" id="L313">                    fu = listener.evaluate(u);</span>
                } else {
<span class="fc" id="L315">                    u = x + sign(tol1, d);</span>
<span class="fc" id="L316">                    fu = listener.evaluate(u);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">                    if (fu &gt; fx) {</span>
                        // If the minimum step in the downhill direction takes us
                        // uphill, then we are done
<span class="fc" id="L320">                        fmin = fx;</span>
<span class="fc" id="L321">                        xmin = x;</span>

<span class="fc" id="L323">                        resultAvailable = true;</span>
<span class="fc" id="L324">                        locked = false;</span>
<span class="fc" id="L325">                        return;</span>
                    }
                }

                // Now all the housekeeping, sigh
<span class="fc" id="L330">                du = derivativeListener.evaluate(u);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">                if (fu &lt;= fx) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">                    if (u &gt;= x) {</span>
<span class="fc" id="L333">                        a = x;</span>
                    } else {
<span class="fc" id="L335">                        b = x;</span>
                    }
<span class="fc" id="L337">                    v1[0] = v;</span>
<span class="fc" id="L338">                    v2[0] = fv;</span>
<span class="fc" id="L339">                    v3[0] = dv;</span>
<span class="fc" id="L340">                    mov3(v1, v2, v3, w, fw, dw);</span>
<span class="fc" id="L341">                    v = v1[0];</span>
<span class="fc" id="L342">                    fv = v2[0];</span>
<span class="fc" id="L343">                    dv = v3[0];</span>


<span class="fc" id="L346">                    v1[0] = w;</span>
<span class="fc" id="L347">                    v2[0] = fw;</span>
<span class="fc" id="L348">                    v3[0] = dw;</span>
<span class="fc" id="L349">                    mov3(v1, v2, v3, x, fx, dx);</span>
<span class="fc" id="L350">                    w = v1[0];</span>
<span class="fc" id="L351">                    fw = v2[0];</span>
<span class="fc" id="L352">                    dw = v3[0];</span>

<span class="fc" id="L354">                    v1[0] = x;</span>
<span class="fc" id="L355">                    v2[0] = fx;</span>
<span class="fc" id="L356">                    v3[0] = dx;</span>
<span class="fc" id="L357">                    mov3(v1, v2, v3, u, fu, du);</span>
<span class="fc" id="L358">                    x = v1[0];</span>
<span class="fc" id="L359">                    fx = v2[0];</span>
<span class="fc" id="L360">                    dx = v3[0];</span>
                } else {
<span class="fc bfc" id="L362" title="All 2 branches covered.">                    if (u &lt; x) {</span>
<span class="fc" id="L363">                        a = u;</span>
                    } else {
<span class="fc" id="L365">                        b = u;</span>
                    }
<span class="fc bfc" id="L367" title="All 4 branches covered.">                    if (fu &lt;= fw || w == x) {</span>
<span class="fc" id="L368">                        v1[0] = v;</span>
<span class="fc" id="L369">                        v2[0] = fv;</span>
<span class="fc" id="L370">                        v3[0] = dv;</span>
<span class="fc" id="L371">                        mov3(v1, v2, v3, w, fw, dw);</span>
<span class="fc" id="L372">                        v = v1[0];</span>
<span class="fc" id="L373">                        fv = v2[0];</span>
<span class="fc" id="L374">                        dv = v3[0];</span>

<span class="fc" id="L376">                        v1[0] = w;</span>
<span class="fc" id="L377">                        v2[0] = fw;</span>
<span class="fc" id="L378">                        v3[0] = dw;</span>
<span class="fc" id="L379">                        mov3(v1, v2, v3, u, fu, du);</span>
<span class="fc" id="L380">                        w = v1[0];</span>
<span class="fc" id="L381">                        fw = v2[0];</span>
<span class="fc" id="L382">                        dw = v3[0];</span>
<span class="pc bpc" id="L383" title="1 of 6 branches missed.">                    } else if (fu &lt; fv || v == x || v == w) {</span>
<span class="fc" id="L384">                        v1[0] = v;</span>
<span class="fc" id="L385">                        v2[0] = fv;</span>
<span class="fc" id="L386">                        v3[0] = dv;</span>
<span class="fc" id="L387">                        mov3(v1, v2, v3, u, fu, du);</span>
<span class="fc" id="L388">                        v = v1[0];</span>
<span class="fc" id="L389">                        fv = v2[0];</span>
<span class="fc" id="L390">                        dv = v3[0];</span>
                    }
                }

<span class="fc bfc" id="L394" title="All 2 branches covered.">                if (iterationCompletedListener != null) {</span>
<span class="fc" id="L395">                    iterationCompletedListener.onIterationCompleted(this, iter, ITMAX);</span>
                }
            }

<span class="nc" id="L399">        } catch (final EvaluationException e) {</span>
<span class="nc" id="L400">            throw new OptimizationException(e);</span>
        } finally {
<span class="fc" id="L402">            locked = false;</span>
        }

        // Too many iterations in Derivative Brent
<span class="nc" id="L406">        throw new OptimizationException();</span>
    }

    /**
     * Returns boolean indicating whether this instance is ready to start the
     * estimation of a local minimum.
     * This instance will be ready once a listener, derivative listener and
     * bracket are available.
     *
     * @return True if ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="pc bpc" id="L419" title="1 of 6 branches missed.">        return isListenerAvailable() &amp;&amp; isDerivativeListenerAvailable() &amp;&amp; isBracketAvailable();</span>
    }

    /**
     * Internal method to set tolerance. Estimated result will be found with an
     * accuracy below or equal to provided tolerance value.
     *
     * @param tolerance Tolerance value.
     * @throws IllegalArgumentException Raised if tolerance is negative.
     */
    private void internalSetTolerance(final double tolerance) {
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (tolerance &lt; MIN_TOLERANCE) {</span>
<span class="fc" id="L431">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L433">        this.tolerance = tolerance;</span>
<span class="fc" id="L434">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>