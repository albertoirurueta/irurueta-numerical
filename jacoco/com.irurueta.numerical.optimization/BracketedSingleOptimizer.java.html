<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BracketedSingleOptimizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-numerical</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.numerical.optimization</a> &gt; <span class="el_source">BracketedSingleOptimizer.java</span></div><h1>BracketedSingleOptimizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.numerical.optimization;

import com.irurueta.numerical.EvaluationException;
import com.irurueta.numerical.InvalidBracketRangeException;
import com.irurueta.numerical.LockedException;
import com.irurueta.numerical.NotAvailableException;
import com.irurueta.numerical.NotReadyException;
import com.irurueta.numerical.SingleDimensionFunctionEvaluatorListener;

/**
 * This class searches for brackets of values containing a minimum in a single
 * dimension function.
 * A bracket is a set of points: &quot;a&quot; a minimum evaluation point,
 * &quot;b&quot; a middle evaluation point and &quot;c&quot; a maximum evaluation where a &amp;lt;= b
 * &amp;lt;= c, and where f(b) &amp;lt;= f(a) and f(b) &amp;lt;= f(c).
 * This class uses a downhill algorithm that is better suited to continuous
 * functions. Other functions might not obtain reliable results when using this
 * algorithm to obtain a bracket of points.
 * Some subclasses of this class will implement algorithms to refine the
 * solution obtained in a bracket in order to find an accurate estimation of a
 * minimum.
 * Some algorithms might not need to previously compute a bracket and will
 * simply search for a minimum in all the range of possible values, whereas
 * other algorithms will require first the computation of a bracket.
 * In either case, computing a bracket prior estimating a minimum will always
 * ensure that a more reliable solution will be found.
 * Besides, bracket computation is required when a function contains several
 * minima and search of an accurate minimum estimation is desired to be
 * restricted to a certain range of values.
 */
public abstract class BracketedSingleOptimizer extends SingleOptimizer {

    /**
     * The default ratio by which intervals are magnified and.
     */
    public static final double GOLD = 1.618034;

    /**
     * The maximum magnification allowed for a parabolic-fit step.
     */
    public static final double GLIMIT = 100.0;

    /**
     * Small value representing machine precision.
     */
    public static final double TINY = 1e-20;

    /**
     * Default minimum evaluation point where the bracket is supposed to start
     * By default, if no bracket is computed, the whole range of values is used
     * for minimum estimation.
     */
    public static final double DEFAULT_MIN_EVAL_POINT = -Double.MAX_VALUE;

    /**
     * Default middle evaluation point where the bracket is supposed to start
     * By default, if no bracket is computed, the whole range of values is used
     * for minimum estimation.
     */
    public static final double DEFAULT_MIDDLE_EVAL_POINT = 0.0;

    /**
     * Default maximum evaluation point where the bracket is supposed to start
     * By default, if no bracket is computed, the whole range of values is used
     * for minimum estimation.
     */
    public static final double DEFAULT_MAX_EVAL_POINT = Double.MAX_VALUE;

    /**
     * Minimum evaluation point inside the bracket.
     */
    protected double ax;

    /**
     * Middle evaluation point inside the bracket.
     */
    protected double bx;

    /**
     * Maximum evaluation point inside the bracket.
     */
    protected double cx;

    /**
     * Boolean indicating whether a bracket has been provided or computed.
     */
    private boolean bracketAvailable;

    /**
     * Function evaluation value at minimum evaluation point inside the bracket.
     */
    private double fa;

    /**
     * Function evaluation value at middle evaluation point inside the bracket.
     */
    private double fb;

    /**
     * Function evaluation value at maximum evaluation point inside the bracket.
     */
    private double fc;

    /**
     * Boolean indicating whether function evaluation at bracket limits and
     * middle point are available or not.
     */
    private boolean bracketEvaluationAvailable;

    /**
     * Constructor. Creates an instance with provided bracket of values.
     *
     * @param minEvalPoint    Minimum bracket evaluation point.
     * @param middleEvalPoint Middle bracket evaluation point.
     * @param maxEvalPoint    Maximum bracket evaluation point.
     * @throws InvalidBracketRangeException Raised if the following condition is
     *                                      not met: minEvalPoint &amp;lt;= middleEvalPoint &amp;lt;= maxEvalPoint.
     */
    protected BracketedSingleOptimizer(
            final double minEvalPoint, final double middleEvalPoint, final double maxEvalPoint)
<span class="fc" id="L136">            throws InvalidBracketRangeException {</span>
<span class="fc" id="L137">        internalSetBracket(minEvalPoint, middleEvalPoint, maxEvalPoint);</span>
<span class="fc" id="L138">    }</span>

    /**
     * Empty Constructor. Creates an instance using default bracket values.
     */
<span class="fc" id="L143">    protected BracketedSingleOptimizer() {</span>
<span class="fc" id="L144">        ax = DEFAULT_MIN_EVAL_POINT;</span>
<span class="fc" id="L145">        bx = DEFAULT_MIDDLE_EVAL_POINT;</span>
<span class="fc" id="L146">        cx = DEFAULT_MAX_EVAL_POINT;</span>
<span class="fc" id="L147">        bracketAvailable = true;</span>
<span class="fc" id="L148">    }</span>

    /**
     * Constructor. Creates an instance with provided bracket of values and a
     * listener to get single dimension function evaluations.
     *
     * @param listener        Listener to evaluate a function.
     * @param minEvalPoint    Minimum bracket evaluation point.
     * @param middleEvalPoint Middle bracket evaluation point.
     * @param maxEvalPoint    Maximum bracket evaluation point.
     * @throws InvalidBracketRangeException Raised if the following condition is
     *                                      not met: minEvalPoint &amp;lt;= middleEvalPoint &amp;lt;= maxEvalPoint.
     */
    protected BracketedSingleOptimizer(
            final SingleDimensionFunctionEvaluatorListener listener, final double minEvalPoint,
            final double middleEvalPoint, final double maxEvalPoint) throws InvalidBracketRangeException {
<span class="fc" id="L164">        super(listener);</span>
<span class="fc" id="L165">        internalSetBracket(minEvalPoint, middleEvalPoint, maxEvalPoint);</span>
<span class="fc" id="L166">    }</span>

    /**
     * Sets a bracket of values to later search for a minimum. A local minimum
     * will only be search within the minimum and maximum evaluation points of
     * a given bracket.
     * If bracket is not provided, it can also be computed from a default or
     * coarse set of points in order to obtain a more refined bracket so that
     * a minimum search can be estimated more precisely.
     *
     * @param minEvalPoint    Minimum bracket evaluation point.
     * @param middleEvalPoint Middle bracket evaluation point.
     * @param maxEvalPoint    Maximum bracket evaluation point.
     * @throws InvalidBracketRangeException Raised if the following condition is
     *                                      not met: minEvalPoint &amp;lt;= middleEvalPoint &amp;lt;= maxEvalPoint.
     * @throws LockedException              Raised if this instance is locked. This instance
     *                                      will be locked while doing some operations. Attempting to change any
     *                                      parameter while being locked will raise this exception.
     */
    public void setBracket(
            final double minEvalPoint, final double middleEvalPoint, final double maxEvalPoint) throws LockedException,
            InvalidBracketRangeException {

<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L190">            throw new LockedException();</span>
        }
<span class="fc" id="L192">        internalSetBracket(minEvalPoint, middleEvalPoint, maxEvalPoint);</span>
<span class="fc" id="L193">    }</span>

    /**
     * Returns boolean indicating whether a bracket has been provided or
     * computed and is available for retrieval.
     *
     * @return true if a bracket has been provided, false otherwise.
     */
    public boolean isBracketAvailable() {
<span class="fc" id="L202">        return bracketAvailable;</span>
    }

    /**
     * Returns minimum evaluation point where the bracket starts
     *
     * @return Minimum evaluation point.
     * @throws NotAvailableException Raised if not provided or computed.
     */
    public double getMinEvaluationPoint() throws NotAvailableException {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (!isBracketAvailable()) {</span>
<span class="nc" id="L213">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L216">        return ax;</span>
    }

    /**
     * Returns middle evaluation point within the bracket.
     *
     * @return Middle evaluation point.
     * @throws NotAvailableException Raised if not provided or computed.
     */
    public double getMiddleEvaluationPoint() throws NotAvailableException {
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (!isBracketAvailable()) {</span>
<span class="nc" id="L227">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L230">        return bx;</span>
    }

    /**
     * Returns maximum evaluation point whether the bracket finishes.
     *
     * @return Maximum evaluation point.
     * @throws NotAvailableException Raised if not provided or computed.
     */
    public double getMaxEvaluationPoint() throws NotAvailableException {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (!isBracketAvailable()) {</span>
<span class="nc" id="L241">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L244">        return cx;</span>
    }

    /**
     * Returns single dimension function evaluation at provided or computed
     * minimum evaluation point where the bracket starts.
     *
     * @return Function evaluation at bracket's minimum evaluation point.
     * @throws NotAvailableException Raised if bracket evaluations are not
     *                               available.
     */
    public double getEvaluationAtMin() throws NotAvailableException {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (!areBracketEvaluationsAvailable()) {</span>
<span class="fc" id="L257">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L260">        return fa;</span>
    }

    /**
     * Returns single dimension function evaluation at provided or computed
     * middle evaluation point within the bracket.
     *
     * @return Function evaluation at bracket's middle evaluation point.
     * @throws NotAvailableException Raised if bracket evaluations are not
     *                               available.
     */
    public double getEvaluationAtMiddle() throws NotAvailableException {
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (!areBracketEvaluationsAvailable()) {</span>
<span class="fc" id="L273">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L276">        return fb;</span>
    }

    /**
     * Returns single dimension function evaluation at provided or computed
     * maximum evaluation point where the bracket finishes.
     *
     * @return Function evaluation at bracket's maximum evaluation point.
     * @throws NotAvailableException Raised if bracket evaluations are not
     *                               available.
     */
    public double getEvaluationAtMax() throws NotAvailableException {
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (!areBracketEvaluationsAvailable()) {</span>
<span class="fc" id="L289">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L292">        return fc;</span>
    }

    /**
     * Computes a bracket of values using provided values as a starting point.
     * Given a function f, and given distinct initial points ax and bx, this
     * routine searches in the downhill direction (defined by the function as
     * evaluated at the initial points) and returns.
     * ax (minimum evaluation point), bx (middle evaluation point), cx (maximum
     * evaluation point) that bracket a minimum of the function. Also returned
     * are the function values at the three points fa, fb, and fc, which are the
     * function evaluations at minimum, middle and maximum bracket points.
     *
     * @param minEvalPoint    Initial minimum evaluation point of bracket.
     * @param middleEvalPoint Initial middle evaluation point of bracket.
     * @throws LockedException              Raised if this instance is locked. This instance
     *                                      will be locked while doing some operations. Attempting to change any
     *                                      parameter while being locked will raise this exception.
     * @throws NotReadyException            Raised if this instance is not ready because a
     *                                      listener has not yet been provided.
     * @throws InvalidBracketRangeException Raised if minEvalPoint &amp;lt;
     *                                      middleEvalPoint.
     * @throws OptimizationException        Raised if a bracket couldn't be found .
     *                                      because convergence was not achieved or function evaluation failed.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void computeBracket(final double minEvalPoint, final double middleEvalPoint) throws LockedException,
            NotReadyException, InvalidBracketRangeException, OptimizationException {

<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L322">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L325">            throw new NotReadyException();</span>
        }
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (minEvalPoint &gt; middleEvalPoint) {</span>
<span class="nc" id="L328">            throw new InvalidBracketRangeException();</span>
        }

<span class="fc" id="L331">        locked = true;</span>

<span class="fc" id="L333">        final var a = new double[1];</span>
<span class="fc" id="L334">        final var b = new double[1];</span>
<span class="fc" id="L335">        final var c = new double[1];</span>

        try {
<span class="fc" id="L338">            ax = minEvalPoint;</span>
<span class="fc" id="L339">            bx = middleEvalPoint;</span>
            double fu;
<span class="fc" id="L341">            fa = listener.evaluate(ax);</span>
<span class="fc" id="L342">            fb = listener.evaluate(bx);</span>

            //switch roles of a and b so that we can go downhill in the
            //direction from a to b
<span class="fc bfc" id="L346" title="All 2 branches covered.">            if (fb &gt; fa) {</span>
<span class="fc" id="L347">                a[0] = ax;</span>
<span class="fc" id="L348">                b[0] = bx;</span>
<span class="fc" id="L349">                swap(a, b);</span>
<span class="fc" id="L350">                ax = a[0];</span>
<span class="fc" id="L351">                bx = b[0];</span>

<span class="fc" id="L353">                a[0] = fa;</span>
<span class="fc" id="L354">                b[0] = fb;</span>
<span class="fc" id="L355">                swap(a, b);</span>
<span class="fc" id="L356">                a[0] = fa;</span>
<span class="fc" id="L357">                b[0] = fb;</span>
            }

            //First guess for c
<span class="fc" id="L361">            cx = bx + GOLD * (bx - ax);</span>
<span class="fc" id="L362">            fc = listener.evaluate(cx);</span>

            //Keep returning here until we bracket.
<span class="fc bfc" id="L365" title="All 2 branches covered.">            while (fb &gt; fc) {</span>
                //Compute u by parabolic extrapolation from a, b, c. TINY is
                //used to prevent any possible division by zero.
<span class="fc" id="L368">                final var r = (bx - ax) * (fb - fc);</span>
<span class="fc" id="L369">                final var q = (bx - cx) * (fb - fa);</span>
<span class="fc" id="L370">                var u = bx - ((bx - cx) * q - (bx - ax) * r) /</span>
<span class="fc" id="L371">                        (2.0 * sign(Math.max(Math.abs(q - r), TINY), q - r));</span>
<span class="fc" id="L372">                final var ulim = bx + GLIMIT * (cx - bx);</span>

                //We won't go farther than this. Test various possibilities:
<span class="fc bfc" id="L375" title="All 2 branches covered.">                if ((bx - u) * (u - cx) &gt; 0.0) {</span>
                    //Parabolic u is between b and c: try it.
<span class="fc" id="L377">                    fu = listener.evaluate(u);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">                    if (fu &lt; fc) {</span>
                        //Got a minimum between b and c.
<span class="fc" id="L380">                        ax = bx;</span>
<span class="fc" id="L381">                        bx = u;</span>
<span class="fc" id="L382">                        fa = fb;</span>
<span class="fc" id="L383">                        fb = fu;</span>
<span class="fc" id="L384">                        break;</span>

<span class="pc bpc" id="L386" title="1 of 2 branches missed.">                    } else if (fu &gt; fb) {</span>
                        //Got a minimum between a and u
<span class="nc" id="L388">                        cx = u;</span>
<span class="nc" id="L389">                        fc = fu;</span>
<span class="nc" id="L390">                        break;</span>
                    }

                    //Parabolic fit was no use. Use default magnification.
<span class="fc" id="L394">                    u = cx + GOLD * (cx - bx);</span>
<span class="fc" id="L395">                    fu = listener.evaluate(u);</span>

<span class="fc bfc" id="L397" title="All 2 branches covered.">                } else if ((cx - u) * (u - ulim) &gt; 0.0) {</span>
                    //Parabolic fit is between c and its allowed limit
<span class="fc" id="L399">                    fu = listener.evaluate(u);</span>

<span class="fc bfc" id="L401" title="All 2 branches covered.">                    if (fu &lt; fc) {</span>
<span class="fc" id="L402">                        a[0] = bx;</span>
<span class="fc" id="L403">                        b[0] = cx;</span>
<span class="fc" id="L404">                        c[0] = u;</span>
<span class="fc" id="L405">                        shift3(a, b, c, u + GOLD * (u - cx));</span>
<span class="fc" id="L406">                        bx = a[0];</span>
<span class="fc" id="L407">                        cx = b[0];</span>
<span class="fc" id="L408">                        u = c[0];</span>

<span class="fc" id="L410">                        a[0] = fb;</span>
<span class="fc" id="L411">                        b[0] = fc;</span>
<span class="fc" id="L412">                        c[0] = fu;</span>
<span class="fc" id="L413">                        shift3(a, b, c, listener.evaluate(u));</span>
<span class="fc" id="L414">                        fb = a[0];</span>
<span class="fc" id="L415">                        fc = b[0];</span>
<span class="fc" id="L416">                        fu = c[0];</span>
                    }
<span class="fc bfc" id="L418" title="All 2 branches covered.">                } else if ((u - ulim) * (ulim - cx) &gt;= 0.0) {</span>
                    //Limit parabolic u to maximum allowed value.
<span class="fc" id="L420">                    u = ulim;</span>
<span class="fc" id="L421">                    fu = listener.evaluate(u);</span>
                } else {
                    //Reject parabolic u, use default magnification
<span class="fc" id="L424">                    u = cx + GOLD * (cx - bx);</span>
<span class="fc" id="L425">                    fu = listener.evaluate(u);</span>
                }
                //Eliminate the oldest point and continue
<span class="fc" id="L428">                a[0] = ax;</span>
<span class="fc" id="L429">                b[0] = bx;</span>
<span class="fc" id="L430">                c[0] = cx;</span>
<span class="fc" id="L431">                shift3(a, b, c, u);</span>
<span class="fc" id="L432">                ax = a[0];</span>
<span class="fc" id="L433">                bx = b[0];</span>
<span class="fc" id="L434">                cx = c[0];</span>

<span class="fc" id="L436">                a[0] = fa;</span>
<span class="fc" id="L437">                b[0] = fb;</span>
<span class="fc" id="L438">                c[0] = fc;</span>
<span class="fc" id="L439">                shift3(a, b, c, fu);</span>
<span class="fc" id="L440">                fa = a[0];</span>
<span class="fc" id="L441">                fb = b[0];</span>
<span class="fc" id="L442">                fc = c[0];</span>
<span class="fc" id="L443">            }</span>
<span class="nc" id="L444">        } catch (final EvaluationException e) {</span>
<span class="nc" id="L445">            throw new OptimizationException(e);</span>
        } finally {
<span class="fc" id="L447">            locked = false;</span>
        }

<span class="fc" id="L450">        bracketAvailable = true;</span>
<span class="fc" id="L451">        bracketEvaluationAvailable = true;</span>
<span class="fc" id="L452">    }</span>

    /**
     * Computes a bracket of values using provided value as a starting point,
     * and assuming that bracket finishes at Double.MAX_VALUE.
     * Given a function f, and given distinct initial points ax and bx = 0.0,
     * this routine searches in the downhill direction (defined by the function
     * as evaluated at the initial points) and returns
     * ax (minimum evaluation point), bx (middle evaluation point), cx (maximum
     * evaluation point) that bracket a minimum of the function. Also returned
     * are the function values at the three points fa, fb, and fc, which are the
     * function evaluations at minimum, middle and maximum bracket points.
     *
     * @param minEvalPoint Initial minimum evaluation point of bracket.
     * @throws LockedException              Raised if this instance is locked. This instance
     *                                      will be locked while doing some operations. Attempting to change any
     *                                      parameter while being locked will raise this exception.
     * @throws NotReadyException            Raised if this instance is not ready because a
     *                                      listener has not yet been provided.
     * @throws InvalidBracketRangeException Raised if minEvalPoint &amp;lt; 0.0.
     * @throws OptimizationException        Raised if a bracket couldn't be found
     *                                      because convergence was not achieved or function evaluation failed.
     */
    public void computeBracket(final double minEvalPoint) throws LockedException, NotReadyException,
            OptimizationException, InvalidBracketRangeException {
<span class="nc" id="L477">        computeBracket(minEvalPoint, DEFAULT_MIDDLE_EVAL_POINT);</span>
<span class="nc" id="L478">    }</span>

    /**
     * Computes a bracket of values using the whole range of possible values as
     * an initial guess.
     * Given a function f, and given distinct initial points ax =
     * -Double.MAX_VALUE and bx = 0.0, this
     * routine searches in the downhill direction (defined by the function as
     * evaluated at the initial points) and returns
     * ax (minimum evaluation point), bx (middle evaluation point), cx (maximum
     * evaluation point) that bracket a minimum of the function. Also returned
     * are the function values at the three points fa, fb, and fc, which are the
     * function evaluations at minimum, middle and maximum bracket points
     *
     * @throws LockedException       Raised if this instance is locked. This instance
     *                               will be locked while doing some operations. Attempting to change any
     *                               parameter while being locked will raise this exception.
     * @throws NotReadyException     Raised if this instance is not ready because a
     *                               listener has not yet been provided.
     * @throws OptimizationException Raised if a bracket couldn't be found
     *                               because convergence was not achieved or function evaluation failed.
     */
    public void computeBracket() throws LockedException, NotReadyException, OptimizationException {
        try {
<span class="fc" id="L502">            computeBracket(DEFAULT_MIN_EVAL_POINT, DEFAULT_MIDDLE_EVAL_POINT);</span>
<span class="nc" id="L503">        } catch (InvalidBracketRangeException ignore) {</span>
            //never happens
<span class="fc" id="L505">        }</span>
<span class="fc" id="L506">    }</span>

    /**
     * Computes function evaluations at provided or estimated bracket locations.
     * After calling this method bracket evaluations will be available.
     *
     * @throws LockedException       Raised if this instance is locked. This instance
     *                               will be locked while doing some operations. Attempting to change any
     *                               parameter while being locked will raise this exception.
     * @throws NotReadyException     Raised if this instance is not ready because a
     *                               listener has not yet been provided.
     * @throws OptimizationException Raised if function evaluation failed.
     */
    public void evaluateBracket() throws LockedException, NotReadyException, OptimizationException {

<span class="pc bpc" id="L521" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L522">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L525">            throw new NotReadyException();</span>
        }

<span class="fc" id="L528">        locked = true;</span>

        try {
<span class="fc" id="L531">            fa = listener.evaluate(ax);</span>
<span class="fc" id="L532">            fb = listener.evaluate(bx);</span>
<span class="fc" id="L533">            fc = listener.evaluate(cx);</span>
<span class="nc" id="L534">        } catch (final EvaluationException e) {</span>
<span class="nc" id="L535">            throw new OptimizationException(e);</span>
        } finally {
<span class="fc" id="L537">            locked = false;</span>
        }

<span class="fc" id="L540">        bracketEvaluationAvailable = true;</span>
<span class="fc" id="L541">    }</span>

    /**
     * Returns boolean indicating whether bracket evaluations are available for
     * retrieval.
     *
     * @return True if bracket evaluations are available, false otherwise.
     */
    public boolean areBracketEvaluationsAvailable() {
<span class="fc" id="L550">        return bracketEvaluationAvailable;</span>
    }

    /**
     * Internal method to determine whether a and b have the same sign.
     *
     * @param a Value to be compared.
     * @param b Value to be compared.
     * @return Returns &quot;a&quot; if &quot;a&quot; and &quot;b&quot; have the same sign or &quot;-a&quot; otherwise.
     */
    protected double sign(final double a, final double b) {
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (b &gt;= 0.0) {</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">            return a &gt;= 0.0 ? a : -a;</span>
        } else {
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            return a &gt;= 0.0 ? -a : a;</span>
        }
    }

    /**
     * Pushes &quot;b&quot; value into &quot;a&quot;, and &quot;c&quot; value into &quot;b&quot;. &quot;a&quot; and &quot;b&quot; are in/out parameters.
     * Results will be available at a[0] and b[0] after executing this method.
     *
     * @param a a value to be lost.
     * @param b a value to be shifted into &quot;a&quot;.
     * @param c a value to be shifted into &quot;b&quot;.
     */
    protected void shift2(final double[] a, final double[] b, final double c) {
<span class="fc" id="L577">        a[0] = b[0];</span>
<span class="fc" id="L578">        b[0] = c;</span>
<span class="fc" id="L579">    }</span>

    /**
     * Pushes &quot;b&quot; value into &quot;a&quot;, and &quot;c&quot; value into &quot;b&quot; and &quot;d&quot; value into &quot;c&quot;. &quot;a&quot;, &quot;b&quot; and &quot;c&quot;
     * are in/out parameters.
     * Results will be available at a[0], b[0] and c[0] after executing this
     * method.
     *
     * @param a a value to be lost.
     * @param b a value to be shifted into &quot;a&quot;.
     * @param c a value to be shifted into &quot;b&quot;.
     * @param d a value to be shifted into &quot;c&quot;.
     */
    protected void shift3(final double[] a, final double[] b, final double[] c, final double d) {
<span class="fc" id="L593">        a[0] = b[0];</span>
<span class="fc" id="L594">        b[0] = c[0];</span>
<span class="fc" id="L595">        c[0] = d;</span>
<span class="fc" id="L596">    }</span>

    /**
     * Moves d, e and f into a[0], b[0] and c[0]. Previously existing values
     * into a, b, c will be lost after executing this method.
     *
     * @param a a value to be set.
     * @param b a value to be set.
     * @param c a value to be set.
     * @param d a value to be copied.
     * @param e a value to be copied.
     * @param f a value to be copied.
     */
    protected void mov3(final double[] a, final double[] b, final double[] c, final double d, final double e,
                        final double f) {
<span class="fc" id="L611">        a[0] = d;</span>
<span class="fc" id="L612">        b[0] = e;</span>
<span class="fc" id="L613">        c[0] = f;</span>
<span class="fc" id="L614">    }</span>

    /**
     * Internal method to swap two values. Value inside a[0] will be swapped
     * with value provided in b[0].
     *
     * @param a Value to be swapped.
     * @param b Value to be swapped.
     */
    private void swap(final double[] a, final double[] b) {
<span class="fc" id="L624">        final var tmp = a[0];</span>
<span class="fc" id="L625">        a[0] = b[0];</span>
<span class="fc" id="L626">        b[0] = tmp;</span>
<span class="fc" id="L627">    }</span>

    /**
     * Internal method to set a bracket of values. This method does not check
     * whether this instance is locked.
     *
     * @param minEvalPoint    Minimum bracket evaluation point.
     * @param middleEvalPoint Middle bracket evaluation point.
     * @param maxEvalPoint    Maximum bracket evaluation point.
     * @throws InvalidBracketRangeException Raised if the following condition is
     *                                      not met: minEvalPoint &amp;lt;= middleEvalPoint &amp;lt;= maxEvalPoint.
     */
    private void internalSetBracket(final double minEvalPoint, final double middleEvalPoint,
                                    final double maxEvalPoint) throws InvalidBracketRangeException {

<span class="fc bfc" id="L642" title="All 4 branches covered.">        if ((minEvalPoint &gt; middleEvalPoint) || (middleEvalPoint &gt; maxEvalPoint)) {</span>
            //which also means || (minEvalPoint &gt; maxEvalPoint))
<span class="fc" id="L644">            throw new InvalidBracketRangeException();</span>
        }

<span class="fc" id="L647">        ax = minEvalPoint;</span>
<span class="fc" id="L648">        bx = middleEvalPoint;</span>
<span class="fc" id="L649">        cx = maxEvalPoint;</span>

<span class="fc" id="L651">        bracketAvailable = true;</span>
<span class="fc" id="L652">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>