<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PowellMultiOptimizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-numerical</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.numerical.optimization</a> &gt; <span class="el_source">PowellMultiOptimizer.java</span></div><h1>PowellMultiOptimizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.numerical.optimization;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.numerical.EvaluationException;
import com.irurueta.numerical.LockedException;
import com.irurueta.numerical.MultiDimensionFunctionEvaluatorListener;
import com.irurueta.numerical.NotAvailableException;
import com.irurueta.numerical.NotReadyException;

/**
 * This class searches for a multi dimension function local minimum.
 * The local minimum is searched by starting the algorithm at a start point
 * and a given direction which should be close and point to the local minimum to
 * be found to achieve the best accuracy with the lowest number of iterations.
 * The implementation of this class is based on Numerical Recipes 3rd ed.
 * Section 10.7 page 509.
 */
public class PowellMultiOptimizer extends LineMultiOptimizer {
    /**
     * Constant defining default tolerance or accuracy to be achieved on the
     * minimum being estimated by this class.
     */
    public static final double DEFAULT_TOLERANCE = 3e-8;

    /**
     * Minimum allowed tolerance value.
     */
    public static final double MIN_TOLERANCE = 0.0;

    /**
     * Maximum allowed iterations.
     */
    public static final int ITMAX = 200;

    /**
     * A small number.
     */
    public static final double TINY = 1e-25;

    /**
     * The fractional tolerance in the function value such that failure to
     * decrease by more than this amount on one iteration signals doneness.
     */
    private double tolerance;

    /**
     * Member contains number of iterations that were needed to estimate a
     * minimum.
     */
    private int iter;

    /**
     * Value of the function at the minimum.
     */
    private double fret;

    /**
     * Set of directions.
     */
    private Matrix ximat;

    /**
     * Empty constructor.
     */
    public PowellMultiOptimizer() {
<span class="fc" id="L83">        super();</span>
<span class="fc" id="L84">        tolerance = DEFAULT_TOLERANCE;</span>
<span class="fc" id="L85">        iter = 0;</span>
<span class="fc" id="L86">        fret = 0.0;</span>
<span class="fc" id="L87">        ximat = null;</span>
<span class="fc" id="L88">    }</span>

    /**
     * Constructor.
     *
     * @param listener  Listener to evaluate a multidimensional function.
     * @param tolerance Tolerance or accuracy to be expected on estimated local
     *                  minimum.
     * @throws IllegalArgumentException Raised if tolerance is negative.
     */
    public PowellMultiOptimizer(final MultiDimensionFunctionEvaluatorListener listener, final double tolerance) {
<span class="fc" id="L99">        super(listener);</span>
<span class="fc" id="L100">        internalSetTolerance(tolerance);</span>
<span class="fc" id="L101">        iter = 0;</span>
<span class="fc" id="L102">        fret = 0.0;</span>
<span class="fc" id="L103">        ximat = null;</span>
<span class="fc" id="L104">    }</span>

    /**
     * Constructor.
     *
     * @param listener   Listener to evaluate a multidimensional function.
     * @param point      Start point where algorithm will be started. Start point
     *                   should be close to the local minimum to be found. Provided array must
     *                   have a length equal to the number of dimensions of the function being
     *                   evaluated, otherwise and exception will be raised when searching for the
     *                   minimum.
     * @param directions Set of directions to start looking for a minimum.
     *                   Provided matrix must have the same rows as the number of dimensions of
     *                   the function being evaluated. Each column will be a direction to search
     *                   for a minimum.
     * @param tolerance  Tolerance or accuracy to be expected on estimated local
     *                   minimum.
     * @throws IllegalArgumentException Raised if provided point and direction
     *                                  don't have the same length or if provided tolerance is negative.
     */
    public PowellMultiOptimizer(
            final MultiDimensionFunctionEvaluatorListener listener, final double[] point, final Matrix directions,
            final double tolerance) {
<span class="fc" id="L127">        super(listener);</span>
<span class="fc" id="L128">        internalSetPointAndDirections(point, directions);</span>
<span class="fc" id="L129">        internalSetTolerance(tolerance);</span>
<span class="fc" id="L130">        iter = 0;</span>
<span class="fc" id="L131">        fret = 0.0;</span>
<span class="fc" id="L132">    }</span>

    /**
     * Returns set of directions to start looking for a minimum.
     * Returned matrix will have the same number of rows as the number of
     * dimensions of the function (or the start point).
     * Each column of the matrix will represent a vector containing a direction
     * to search for a minimum.
     *
     * @return Set of directions.
     * @throws NotAvailableException Raised if this has not yet been provided or
     *                               computed.
     */
    public Matrix getDirections() throws NotAvailableException {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (!areDirectionsAvailable()) {</span>
<span class="fc" id="L147">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L149">        return ximat;</span>
    }

    /**
     * Returns boolean indicating whether set of directions is available for
     * retrieval.
     *
     * @return True if available, false otherwise.
     */
    public boolean areDirectionsAvailable() {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        return ximat != null;</span>
    }

    /**
     * Sets start point and set of directions to start looking for minimum.
     *
     * @param point      Start point where algorithm will be started. Start point
     *                   should be close to the local minimum to be found. Provided array must
     *                   have a length equal to the number of dimensions of the function being
     *                   evaluated, otherwise and exception will be raised when searching for the
     *                   minimum.
     * @param directions Set of directions to start looking for a minimum.
     *                   Provided matrix must have the same rows as the number of dimensions of
     *                   the function being evaluated. Each column will be a direction to search
     *                   for a minimum.
     * @throws LockedException          Raised if this instance is locked.
     * @throws IllegalArgumentException Raised if provided point and direction
     *                                  don't have the same length.
     */
    public void setPointAndDirections(final double[] point, final Matrix directions) throws LockedException {
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L180">            throw new LockedException();</span>
        }
<span class="fc" id="L182">        internalSetPointAndDirections(point, directions);</span>
<span class="fc" id="L183">    }</span>

    /**
     * Sets start point where local minimum is searched nearby.
     *
     * @param startPoint Start point to search for a local minimum
     * @throws LockedException Raised if this instance is locked.
     */
    public void setStartPoint(final double[] startPoint) throws LockedException {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L193">            throw new LockedException();</span>
        }
<span class="fc" id="L195">        p = startPoint;</span>
<span class="fc" id="L196">    }</span>

    /**
     * Returns tolerance or accuracy to be expected on estimated local minimum.
     *
     * @return Tolerance or accuracy to be expected on estimated local minimum.
     */
    public double getTolerance() {
<span class="fc" id="L204">        return tolerance;</span>
    }

    /**
     * Internal method to set tolerance or accuracy to be expected on estimated
     * local minimum.
     * This method does not check whether this instance is locked.
     *
     * @param tolerance Tolerance or accuracy to be expected on estimated local
     *                  minimum.
     * @throws IllegalArgumentException Raised if provided tolerance is
     *                                  negative.
     */
    private void internalSetTolerance(final double tolerance) {
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (tolerance &lt; MIN_TOLERANCE) {</span>
<span class="fc" id="L219">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L221">        this.tolerance = tolerance;</span>
<span class="fc" id="L222">    }</span>

    /**
     * Sets tolerance or accuracy to be expected on estimated local minimum.
     *
     * @param tolerance Tolerance or accuracy to be expected on estimated local
     *                  minimum.
     * @throws LockedException          Raised if this instance is locked.
     * @throws IllegalArgumentException Raised if provided tolerance is
     *                                  negative.
     */
    public void setTolerance(final double tolerance) throws LockedException {
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L235">            throw new LockedException();</span>
        }
<span class="fc" id="L237">        internalSetTolerance(tolerance);</span>
<span class="fc" id="L238">    }</span>

    /**
     * This function estimates a function minimum.
     * Implementations of this class will usually search a local minimum close
     * to a start point and will start looking into provided start direction.
     * Minimization of a function f. Input consists of an initial starting
     * point p. The initial matrix ximat, whose columns contain the initial
     * set of directions, is set to the identity. Returned is the best point
     * found, at which point fret is the minimum function value and iter is
     * the number of iterations taken.
     *
     * @throws LockedException       Raised if this instance is locked, because
     *                               estimation is being computed.
     * @throws NotReadyException     Raised if this instance is not ready, because
     *                               a listener, a gradient listener and a start point haven't been provided.
     * @throws OptimizationException Raised if the algorithm failed because of
     *                               lack of convergence or because function couldn't be evaluated.
     */
    @Override
    public void minimize() throws LockedException, NotReadyException, OptimizationException {

<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L261">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L264">            throw new NotReadyException();</span>
        }

<span class="fc" id="L267">        locked = true;</span>

<span class="fc" id="L269">        buildDirections();</span>

        // in case that set of directions have been directly provided, we check
        // for correctness
<span class="fc" id="L273">        final int n = p.length;</span>
<span class="pc bpc" id="L274" title="2 of 4 branches missed.">        if (ximat.getRows() != ximat.getColumns() || ximat.getRows() != n) {</span>
<span class="nc" id="L275">            locked = false;</span>
<span class="nc" id="L276">            throw new OptimizationException();</span>
        }

        double fptt;
<span class="fc" id="L280">        final var pt = new double[n];</span>
<span class="fc" id="L281">        final var ptt = new double[n];</span>

        // set vector of directions
<span class="pc bpc" id="L284" title="3 of 4 branches missed.">        if (!isDirectionAvailable() || xi.length != n) {</span>
<span class="fc" id="L285">            xi = new double[n];</span>
        }

        try {
<span class="fc" id="L289">            fret = listener.evaluate(p);</span>

            // save the initial point
<span class="fc" id="L292">            System.arraycopy(p, 0, pt, 0, n);</span>

<span class="fc" id="L294">            for (iter = 0; ; ++iter) {</span>
<span class="fc" id="L295">                final var fp = fret;</span>
<span class="fc" id="L296">                var ibig = 0;</span>
                // Will be the biggest function decrease
<span class="fc" id="L298">                var del = 0.0;</span>
                // In each iteration, loop over all directions in the set.
<span class="fc bfc" id="L300" title="All 2 branches covered.">                for (var i = 0; i &lt; n; i++) {</span>
                    // Copy the direction contained in i-th column of ximat
<span class="fc" id="L302">                    ximat.getSubmatrixAsArray(0, i, n - 1, i, xi);</span>
<span class="fc" id="L303">                    fptt = fret;</span>

                    // minimize along it, and record it if it is the largest
                    // decrease so far.
<span class="fc" id="L307">                    fret = linmin();</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">                    if (fptt - fret &gt; del) {</span>
<span class="fc" id="L309">                        del = fptt - fret;</span>
<span class="fc" id="L310">                        ibig = i + 1;</span>
                    }
                }

                // Here comes the termination criterion.
<span class="fc" id="L315">                if (2.0 * (fp - fret) &lt;= tolerance * (Math.abs(fp) +</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">                        Math.abs(fret)) + TINY) {</span>
                    // minimum has been found
<span class="fc" id="L318">                    break;</span>
                }
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">                if (iter == ITMAX) {</span>
                    // too many iterations
<span class="nc" id="L322">                    locked = false;</span>
<span class="nc" id="L323">                    throw new OptimizationException();</span>
                }

                // Construct the extrapolated point and the average direction
                // moved. Save the old starting point
<span class="fc bfc" id="L328" title="All 2 branches covered.">                for (var j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L329">                    ptt[j] = 2.0 * p[j] - pt[j];</span>
<span class="fc" id="L330">                    xi[j] = p[j] - pt[j];</span>
<span class="fc" id="L331">                    pt[j] = p[j];</span>
                }

                // Function value at extrapolated point
<span class="fc" id="L335">                fptt = listener.evaluate(ptt);</span>

<span class="fc bfc" id="L337" title="All 2 branches covered.">                if (fptt &lt; fp) {</span>
<span class="fc" id="L338">                    final var t = 2.0 * (fp - 2.0 * fret + fptt) * sqr(fp - fret - del) - del * sqr(fp - fptt);</span>

<span class="pc bpc" id="L340" title="1 of 2 branches missed.">                    if (t &lt; 0.0) {</span>
                        // Move to the minimum of the new direction, and save the
                        // new direction
<span class="fc" id="L343">                        fret = linmin();</span>

<span class="fc" id="L345">                        ximat.setSubmatrix(0, ibig - 1,</span>
                                n - 1, ibig - 1, ximat,
                                0, n - 1,
                                n - 1, n - 1);
<span class="fc" id="L349">                        ximat.setSubmatrix(0, n - 1,</span>
                                n - 1, n - 1, xi);
                    }
                }

<span class="pc bpc" id="L354" title="1 of 2 branches missed.">                if (iterationCompletedListener != null) {</span>
<span class="fc" id="L355">                    iterationCompletedListener.onIterationCompleted(this, iter, ITMAX);</span>
                }
            }
<span class="nc" id="L358">        } catch (final AlgebraException | EvaluationException e) {</span>
<span class="nc" id="L359">            throw new OptimizationException(e);</span>
        } finally {
<span class="fc" id="L361">            locked = false;</span>
        }

        // set result
<span class="fc" id="L365">        xmin = p;</span>
<span class="fc" id="L366">        resultAvailable = true;</span>
<span class="fc" id="L367">        fmin = fret;</span>
<span class="fc" id="L368">    }</span>

    /**
     * Returns boolean indicating whether this instance is ready to start the
     * estimation of a local minimum.
     * An instance is ready once a listener and a start point are provided.
     *
     * @return True if this instance is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="fc bfc" id="L379" title="All 4 branches covered.">        return isListenerAvailable() &amp;&amp; isStartPointAvailable();</span>
    }

    /**
     * Internal method to set start point and set of directions to start looking
     * for minimum.
     * This method does not check whether this instance is locked.
     *
     * @param point      Start point where algorithm will be started. Start point
     *                   should be close to the local minimum to be found. Provided array must
     *                   have a length equal to the number of dimensions of the function being
     *                   evaluated, otherwise and exception will be raised when searching for the
     *                   minimum.
     * @param directions Set of directions to start looking for a minimum.
     *                   Provided matrix must have the same rows as the number of dimensions of
     *                   the function being evaluated. Each column will be a direction to search
     *                   for a minimum.
     * @throws IllegalArgumentException Raised if provided point and direction
     *                                  don't have the same length.
     */
    private void internalSetPointAndDirections(final double[] point, final Matrix directions) {
<span class="pc bpc" id="L400" title="2 of 4 branches missed.">        if ((point.length != directions.getRows()) || (point.length != directions.getColumns())) {</span>
<span class="nc" id="L401">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L403">        p = point;</span>
<span class="fc" id="L404">        ximat = directions;</span>
<span class="fc" id="L405">        xi = null;</span>
<span class="fc" id="L406">    }</span>

    /**
     * Internal method to build or rebuild the set of directions if needed.
     *
     * @throws NotReadyException Raised if no start point has yet been provided.
     */
    private void buildDirections() throws NotReadyException {
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (!isStartPointAvailable()) {</span>
<span class="nc" id="L415">            throw new NotReadyException();</span>
        }

<span class="fc" id="L418">        final var n = p.length;</span>

<span class="pc bpc" id="L420" title="5 of 6 branches missed.">        if (areDirectionsAvailable() &amp;&amp; (ximat.getRows() == n) &amp;&amp; (ximat.getColumns() == n)) {</span>
<span class="nc" id="L421">            return;</span>
        }

        try {
<span class="fc" id="L425">            ximat = Matrix.identity(n, n);</span>
<span class="nc" id="L426">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L428">        }</span>
<span class="fc" id="L429">    }</span>

    /**
     * Computes the squared value of provided double.
     *
     * @param x Value to be squared.
     * @return Squared value.
     */
    private double sqr(double x) {
<span class="fc" id="L438">        return x * x;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>