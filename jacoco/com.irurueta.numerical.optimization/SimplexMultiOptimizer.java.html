<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimplexMultiOptimizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-numerical</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.numerical.optimization</a> &gt; <span class="el_source">SimplexMultiOptimizer.java</span></div><h1>SimplexMultiOptimizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.numerical.optimization;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.numerical.EvaluationException;
import com.irurueta.numerical.LockedException;
import com.irurueta.numerical.MultiDimensionFunctionEvaluatorListener;
import com.irurueta.numerical.NotAvailableException;
import com.irurueta.numerical.NotReadyException;

import java.util.Arrays;

/**
 * This class searches for a multi dimension function local minimum.
 * The local minimum is searched by starting the algorithm at a start point
 * and a given set of deltas to obtain surrounding points to the start point
 * where the algorithm will be started.
 * The Simplex algorithm will increase or decrease such deltas and move the
 * start point around until the minimum is found.
 * The implementation of this class is based on Numerical Recipes 3rd ed.
 * Section 10.5 page 502.
 */
public class SimplexMultiOptimizer extends MultiOptimizer {
    /**
     * Maximum number of iterations.
     */
    public static final int NMAX = 5000;

    /**
     * Small value considered to be machine precision.
     */
    public static final double TINY = 1e-10;

    /**
     * Constant defining default tolerance or accuracy to be achieved on the
     * minimum being estimated by this class.
     */
    public static final double DEFAULT_TOLERANCE = 3e-8;

    /**
     * Minimum allowed tolerance value.
     */
    public static final double MIN_TOLERANCE = 0.0;

    /**
     * The fractional tolerance in the function value such that failure to
     * decrease by more than this amount on one iteration signals doneness.
     */
    private double ftol;

    /**
     * Number of function evaluations.
     */
    private int nfunc;

    /**
     * Number of points in the simplex.
     */
    private int mpts;

    /**
     * Number of dimensions of current function being optimized.
     */
    private int ndim;

    /**
     * Function values at the vertices of the simples.
     */
    private double[] y;

    /**
     * Current simplex.
     */
    private Matrix p;

    /**
     * Empty constructor.
     */
    public SimplexMultiOptimizer() {
<span class="fc" id="L95">        super();</span>
<span class="fc" id="L96">        nfunc = mpts = ndim = 0;</span>
<span class="fc" id="L97">        y = null;</span>
<span class="fc" id="L98">        p = null;</span>
<span class="fc" id="L99">        ftol = DEFAULT_TOLERANCE;</span>
<span class="fc" id="L100">    }</span>

    /**
     * Constructor.
     *
     * @param listener   Listener to evaluate a multidimensional function.
     * @param startPoint Point where the algorithm is started.
     * @param delta      Delta to find other points close to the start point so that
     *                   an initial simplex is defined.
     * @param tolerance  Tolerance or accuracy to be expected on estimated local
     *                   minimum.
     * @throws IllegalArgumentException Raised if tolerance is negative.
     */
    public SimplexMultiOptimizer(
            final MultiDimensionFunctionEvaluatorListener listener, final double[] startPoint, final double delta,
            final double tolerance) {
<span class="fc" id="L116">        super(listener);</span>
<span class="fc" id="L117">        nfunc = mpts = ndim = 0;</span>
<span class="fc" id="L118">        y = null;</span>
<span class="fc" id="L119">        p = null;</span>
<span class="fc" id="L120">        internalSetTolerance(tolerance);</span>
<span class="fc" id="L121">        internalSetSimplex(startPoint, delta);</span>
<span class="fc" id="L122">    }</span>

    /**
     * Constructor.
     *
     * @param listener   Listener to evaluate a multidimensional function.
     * @param startPoint Point where the algorithm is started.
     * @param deltas     Set of deltas to find other points close to the start point
     *                   so that an initial simplex is defined.
     * @param tolerance  Tolerance or accuracy to be expected on estimated local
     *                   minimum.
     * @throws IllegalArgumentException Raised if tolerance is negative or if
     *                                  deltas don't have the same length as provided start point.
     */
    public SimplexMultiOptimizer(
            final MultiDimensionFunctionEvaluatorListener listener, final double[] startPoint, final double[] deltas,
            final double tolerance) {
<span class="fc" id="L139">        super(listener);</span>
<span class="fc" id="L140">        nfunc = mpts = ndim = 0;</span>
<span class="fc" id="L141">        y = null;</span>
<span class="fc" id="L142">        p = null;</span>
<span class="fc" id="L143">        internalSetTolerance(tolerance);</span>
<span class="fc" id="L144">        internalSetSimplex(startPoint, deltas);</span>
<span class="fc" id="L145">    }</span>

    /**
     * Constructor.
     *
     * @param listener  Listener to evaluate a multidimensional function.
     * @param simplex   Initial simplex to start the algorithm. The simplex is
     *                  a set of points around the minimum to be found.
     * @param tolerance Tolerance or accuracy to be expected on estimated local
     *                  minimum.
     * @throws IllegalArgumentException Raised if tolerance is negative.
     */
    public SimplexMultiOptimizer(
            final MultiDimensionFunctionEvaluatorListener listener, final Matrix simplex, final double tolerance) {
<span class="fc" id="L159">        super(listener);</span>
<span class="fc" id="L160">        nfunc = mpts = ndim = 0;</span>
<span class="fc" id="L161">        y = null;</span>
<span class="fc" id="L162">        p = null;</span>
<span class="fc" id="L163">        internalSetTolerance(tolerance);</span>
<span class="fc" id="L164">        internalSetSimplex(simplex);</span>
<span class="fc" id="L165">    }</span>

    /**
     * Returns current simplex.
     * A simplex is a set of points delimiting an n-dimensional region.
     * The simplex can be seen as the n-dimensional version of a bracket of
     * values.
     * This class must be started at an initial simplex where a minimum will be
     * searched.
     * As the algorithm iterates, the simplex will be moved around and its size
     * will be reduced until a minimum is found.
     *
     * @return Current simplex.
     * @throws NotAvailableException Raised if not provided or computed.
     */
    public Matrix getSimplex() throws NotAvailableException {
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (!isSimplexAvailable()) {</span>
<span class="fc" id="L182">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L184">        return p;</span>
    }

    /**
     * Sets a simplex defined as a central point and a set of surrounding points
     * at distance delta. The simplex will be made of the computed surrounding
     * points.
     *
     * @param startPoint Central point.
     * @param delta      Distance of surrounding points.
     * @throws LockedException Raised if this instance is locked.
     */
    public void setSimplex(final double[] startPoint, final double delta) throws LockedException {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L198">            throw new LockedException();</span>
        }
<span class="fc" id="L200">        internalSetSimplex(startPoint, delta);</span>
<span class="fc" id="L201">    }</span>

    /**
     * Internal method to set a simplex as a central point and a set of
     * surrounding points at distance delta. The simplex will be made of the
     * computed surrounding points.
     * This method does not check whether this instance is locked.
     *
     * @param startPoint Central point.
     * @param delta      Distance of surrounding points.
     */
    private void internalSetSimplex(final double[] startPoint, final double delta) {
<span class="fc" id="L213">        final var deltas = new double[startPoint.length];</span>
<span class="fc" id="L214">        Arrays.fill(deltas, delta);</span>
<span class="fc" id="L215">        internalSetSimplex(startPoint, deltas);</span>
<span class="fc" id="L216">    }</span>

    /**
     * Sets a simplex defined as a central point and a set of surrounding points
     * at their corresponding distance deltas[i], where &quot;i&quot; corresponds to one
     * position of provided array of distances. The simplex will be made of the
     * computed surrounding points.
     *
     * @param startPoint Central point.
     * @param deltas     Distances of surrounding points. Each surrounding point can
     *                   have a different distance than the others. The number of provided
     *                   distances must be equal to the dimension or length of the start point
     *                   array.
     * @throws LockedException          Raised if this instance is locked.
     * @throws IllegalArgumentException Raised if startPoint and deltas don't
     *                                  have the same length.
     */
    public void setSimplex(final double[] startPoint, final double[] deltas) throws LockedException {
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L235">            throw new LockedException();</span>
        }
<span class="fc" id="L237">        internalSetSimplex(startPoint, deltas);</span>
<span class="fc" id="L238">    }</span>

    /**
     * Internal method to set a simplex defined as a central point and a set of
     * surrounding points at their corresponding distance deltas[i], where &quot;i&quot;
     * corresponds to one position of provided array of distances. The simplex
     * will be made of the computed surrounding points.
     *
     * @param startPoint Central point.
     * @param deltas     Distances of surrounding points. Each surrounding point can
     *                   have a different distance than the others. The number of provided
     *                   distances must be equal to the dimension or length of the start point
     *                   array.
     * @throws IllegalArgumentException Raised if startPoint and deltas don't
     *                                  have the same length.
     */
    private void internalSetSimplex(final double[] startPoint, final double[] deltas) {
<span class="fc" id="L255">        final var localndim = startPoint.length;</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (deltas.length != localndim) {</span>
<span class="fc" id="L258">            throw new IllegalArgumentException();</span>
        }

        final Matrix pp;
        try {
<span class="fc" id="L263">            pp = new Matrix(localndim + 1, localndim);</span>
<span class="nc" id="L264">        } catch (final WrongSizeException e) {</span>
<span class="nc" id="L265">            throw new IllegalArgumentException(e);</span>
<span class="fc" id="L266">        }</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        for (var i = 0; i &lt; localndim + 1; i++) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            for (var j = 0; j &lt; localndim; j++) {</span>
<span class="fc" id="L269">                pp.setElementAt(i, j, startPoint[j]);</span>
            }
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (i != 0) {</span>
<span class="fc" id="L272">                pp.setElementAt(i, i - 1, pp.getElementAt(i, i - 1) + deltas[i - 1]);</span>
            }
        }

<span class="fc" id="L276">        internalSetSimplex(pp);</span>
<span class="fc" id="L277">    }</span>

    /**
     * Sets simplex as a matrix containing on each row a point of the simplex.
     * The number of columns defines the dimension of the points in the
     * function, if not properly set, then minimize() method will fail when
     * being called.
     *
     * @param simplex Simplex of points.
     * @throws LockedException Raised if this instance is locked.
     */
    public void setSimplex(final Matrix simplex) throws LockedException {
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L290">            throw new LockedException();</span>
        }
<span class="fc" id="L292">        internalSetSimplex(simplex);</span>
<span class="fc" id="L293">    }</span>

    /**
     * Internal method to Set simplex as a matrix containing on each row a point
     * of the simplex.
     * The number of columns defines the dimension of the points in the
     * function, if not properly set, then minimize() method will fail when
     * being called.
     * This method does not check whether this instance is locked.
     *
     * @param simplex Simplex of points.
     */
    private void internalSetSimplex(final Matrix simplex) {
<span class="fc" id="L306">        p = simplex;</span>
<span class="fc" id="L307">    }</span>

    /**
     * Returns boolean indicating whether a simplex has been provided and is
     * available for retrieval.
     *
     * @return True if available, false otherwise.
     */
    public boolean isSimplexAvailable() {
<span class="fc bfc" id="L316" title="All 2 branches covered.">        return p != null;</span>
    }

    /**
     * Returns function evaluations at simplex points or vertices.
     *
     * @return Function evaluations at simplex vertices.
     * @throws NotAvailableException Raised if not available for retrieval.
     *                               This parameter will be available one minimization has been computed.
     */
    public double[] getEvaluationsAtSimplex() throws NotAvailableException {
<span class="fc bfc" id="L327" title="All 2 branches covered.">        if (!areFunctionEvaluationsAvailable()) {</span>
<span class="fc" id="L328">            throw new NotAvailableException();</span>
        }
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (!areFunctionEvaluationsAvailable()) {</span>
<span class="nc" id="L331">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L333">        return y;</span>
    }

    /**
     * Returns boolean indicating whether function evaluations at simplex
     * vertices are available for retrieval.
     * Function evaluations at simplex vertices will be available one
     * minimization has been computed.
     *
     * @return True if available, false otherwise.
     */
    public boolean areFunctionEvaluationsAvailable() {
<span class="fc bfc" id="L345" title="All 2 branches covered.">        return y != null;</span>
    }

    /**
     * Returns tolerance or accuracy to be expected on estimated local minimum.
     *
     * @return Tolerance or accuracy to be expected on estimated local minimum.
     */
    public double getTolerance() {
<span class="fc" id="L354">        return ftol;</span>
    }

    /**
     * Sets tolerance or accuracy to be expected on estimated local minimum.
     *
     * @param tolerance Tolerance or accuracy to be expected on estimated local
     *                  minimum.
     * @throws LockedException          Raised if this instance is locked.
     * @throws IllegalArgumentException Raised if provided tolerance is
     *                                  negative.
     */
    public void setTolerance(final double tolerance) throws LockedException {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L368">            throw new LockedException();</span>
        }
<span class="fc" id="L370">        internalSetTolerance(tolerance);</span>
<span class="fc" id="L371">    }</span>

    /**
     * Internal method to set tolerance or accuracy to be expected on estimated
     * local minimum.
     * This method does not check whether this instance is locked.
     *
     * @param tolerance Tolerance or accuracy to be expected on estimated local
     *                  minimum.
     * @throws IllegalArgumentException Raised if provided tolerance is
     *                                  negative.
     */
    private void internalSetTolerance(final double tolerance) {
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (tolerance &lt; MIN_TOLERANCE) {</span>
<span class="fc" id="L385">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L387">        ftol = tolerance;</span>
<span class="fc" id="L388">    }</span>

    /**
     * This function estimates a function minimum.
     * Implementations of this class will usually search a local minimum inside
     * a given simplex of points. The algorithm will iterate moving the simplex
     * around and reducing its size until a minimum is found.
     *
     * @throws LockedException       Raised if this instance is locked, because
     *                               estimation is being computed.
     * @throws NotReadyException     Raised if this instance is not ready, because
     *                               a listener, a gradient listener and a start point haven't been provided.
     * @throws OptimizationException Raised if the algorithm failed because of
     *                               lack of convergence or because function couldn't be evaluated.
     */
    @Override
    public void minimize() throws LockedException, NotReadyException, OptimizationException {
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L406">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L409">            throw new NotReadyException();</span>
        }

<span class="fc" id="L412">        locked = true;</span>

        // clean previous result and previous function evaluations
        try {
            int ihi;
            int ilo;
            int inhi;
<span class="fc" id="L419">            mpts = p.getRows();</span>
<span class="fc" id="L420">            ndim = p.getColumns();</span>

<span class="fc" id="L422">            final var psum = new double[ndim];</span>
<span class="fc" id="L423">            final var pmin = new double[ndim];</span>
<span class="fc" id="L424">            final var x = new double[ndim];</span>
<span class="fc" id="L425">            final var v1 = new double[1];</span>
<span class="fc" id="L426">            final var v2 = new double[1];</span>

            // instantiate new function evaluations
<span class="fc" id="L429">            y = new double[mpts];</span>

<span class="fc bfc" id="L431" title="All 2 branches covered.">            for (var i = 0; i &lt; mpts; i++) {</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                for (var j = 0; j &lt; ndim; j++) {</span>
<span class="fc" id="L433">                    x[j] = p.getElementAt(i, j);</span>
                }
<span class="fc" id="L435">                y[i] = listener.evaluate(x);</span>
            }

<span class="fc" id="L438">            nfunc = 0;</span>
<span class="fc" id="L439">            getPsum(p, psum);</span>

            for (; ; ) {
<span class="fc" id="L442">                ilo = 0;</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">                if (y[0] &gt; y[1]) {</span>
<span class="fc" id="L444">                    ihi = 0;</span>
<span class="fc" id="L445">                    inhi = 1;</span>
                } else {
<span class="fc" id="L447">                    ihi = 1;</span>
<span class="fc" id="L448">                    inhi = 0;</span>
                }
<span class="fc bfc" id="L450" title="All 2 branches covered.">                for (var i = 0; i &lt; mpts; i++) {</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                    if (y[i] &lt;= y[ilo]) {</span>
<span class="fc" id="L452">                        ilo = i;</span>
                    }
<span class="fc bfc" id="L454" title="All 2 branches covered.">                    if (y[i] &gt; y[ihi]) {</span>
<span class="fc" id="L455">                        inhi = ihi;</span>
<span class="fc" id="L456">                        ihi = i;</span>
<span class="fc bfc" id="L457" title="All 4 branches covered.">                    } else if (y[i] &gt; y[inhi] &amp;&amp; i != ihi) {</span>
<span class="fc" id="L458">                        inhi = i;</span>
                    }
                }
<span class="fc" id="L461">                final var rtol = 2.0 * Math.abs(y[ihi] - y[ilo]) / (Math.abs(y[ihi]) + Math.abs(y[ilo]) + TINY);</span>

<span class="fc bfc" id="L463" title="All 2 branches covered.">                if (rtol &lt; ftol) {</span>
<span class="fc" id="L464">                    v1[0] = y[0];</span>
<span class="fc" id="L465">                    v2[0] = y[ilo];</span>
<span class="fc" id="L466">                    swap(v1, v2);</span>
<span class="fc" id="L467">                    y[0] = v1[0];</span>
<span class="fc" id="L468">                    y[ilo] = v2[0];</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">                    for (var i = 0; i &lt; ndim; i++) {</span>
<span class="fc" id="L470">                        v1[0] = p.getElementAt(0, i);</span>
<span class="fc" id="L471">                        v2[0] = p.getElementAt(ilo, i);</span>
<span class="fc" id="L472">                        swap(v1, v2);</span>
<span class="fc" id="L473">                        p.setElementAt(0, i, v1[0]);</span>
<span class="fc" id="L474">                        p.setElementAt(ilo, i, v2[0]);</span>
<span class="fc" id="L475">                        pmin[i] = p.getElementAt(0, i);</span>
                    }
<span class="fc" id="L477">                    fmin = y[0];</span>

                    // save result
<span class="fc" id="L480">                    xmin = pmin;</span>
<span class="fc" id="L481">                    resultAvailable = true;</span>

<span class="fc" id="L483">                    return;</span>
                }
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">                if (nfunc &gt;= NMAX) {</span>
<span class="nc" id="L486">                    throw new OptimizationException();</span>
                }

<span class="fc" id="L489">                nfunc += 2;</span>
<span class="fc" id="L490">                var ytry = amotry(p, y, psum, ihi, -1.0, listener);</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">                if (ytry &lt;= y[ilo]) {</span>
<span class="fc" id="L493">                    amotry(p, y, psum, ihi, 2.0, listener);</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                } else if (ytry &gt;= y[inhi]) {</span>
<span class="fc" id="L495">                    var ysave = y[ihi];</span>
<span class="fc" id="L496">                    ytry = amotry(p, y, psum, ihi, 0.5, listener);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">                    if (ytry &gt;= ysave) {</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">                        for (var i = 0; i &lt; mpts; i++) {</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">                            if (i != ilo) {</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">                                for (var j = 0; j &lt; ndim; j++) {</span>
<span class="fc" id="L501">                                    psum[j] = 0.5 * (p.getElementAt(i, j) + p.getElementAt(ilo, j));</span>
<span class="fc" id="L502">                                    p.setElementAt(i, j, psum[j]);</span>
                                }
<span class="fc" id="L504">                                y[i] = listener.evaluate(psum);</span>
                            }
                        }
<span class="fc" id="L507">                        nfunc += ndim;</span>
<span class="fc" id="L508">                        getPsum(p, psum);</span>
                    }
<span class="fc" id="L510">                } else {</span>
<span class="fc" id="L511">                    --nfunc;</span>
                }

<span class="pc bpc" id="L514" title="1 of 2 branches missed.">                if (iterationCompletedListener != null) {</span>
<span class="fc" id="L515">                    iterationCompletedListener.onIterationCompleted(this, nfunc, NMAX);</span>
                }
<span class="fc" id="L517">            }</span>
<span class="nc" id="L518">        } catch (final EvaluationException e) {</span>
<span class="nc" id="L519">            throw new OptimizationException(e);</span>
        } finally {
<span class="fc" id="L521">            locked = false;</span>
        }
    }

    /**
     * Returns boolean indicating whether this instance is ready to start the
     * estimation of a local minimum.
     * An instance is ready once a listener and a simplex are provided.
     *
     * @return True if this instance is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="fc bfc" id="L534" title="All 4 branches covered.">        return isListenerAvailable() &amp;&amp; isSimplexAvailable();</span>
    }

    /**
     * Computes the sum of the elements of each matrix column.
     *
     * @param p    Matrix where columns will be summed.
     * @param psum Array to contain computed sums. Provided array must have a
     *             length equal to the number of matrix columns. This is an output
     *             parameter.
     */
    private void getPsum(final Matrix p, final double[] psum) {
<span class="fc bfc" id="L546" title="All 2 branches covered.">        for (var j = 0; j &lt; ndim; j++) {</span>
<span class="fc" id="L547">            var sum = 0.0;</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">            for (int i = 0; i &lt; mpts; i++) {</span>
<span class="fc" id="L549">                sum += p.getElementAt(i, j);</span>
            }
<span class="fc" id="L551">            psum[j] = sum;</span>
        }
<span class="fc" id="L553">    }</span>

    /**
     * Internal method to move simplex around.
     *
     * @param p        a matrix.
     * @param y        an array.
     * @param psum     another array.
     * @param ihi      a value.
     * @param fac      another value.
     * @param listener a listener to evaluate function to optimize.
     * @return a value returned by the evaluated function.
     * @throws EvaluationException Raised if function evaluation fails.
     */
    private double amotry(final Matrix p, final double[] y, final double[] psum, final int ihi, final double fac,
                          final MultiDimensionFunctionEvaluatorListener listener) throws EvaluationException {
<span class="fc" id="L569">        final var ptry = new double[ndim];</span>
<span class="fc" id="L570">        final var fac1 = (1.0 - fac) / ndim;</span>
<span class="fc" id="L571">        final var fac2 = fac1 - fac;</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        for (var j = 0; j &lt; ndim; j++) {</span>
<span class="fc" id="L573">            ptry[j] = psum[j] * fac1 - p.getElementAt(ihi, j) * fac2;</span>
        }
<span class="fc" id="L575">        final var ytry = listener.evaluate(ptry);</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (ytry &lt; y[ihi]) {</span>
<span class="fc" id="L577">            y[ihi] = ytry;</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">            for (var j = 0; j &lt; ndim; j++) {</span>
<span class="fc" id="L579">                psum[j] += ptry[j] - p.getElementAt(ihi, j);</span>
<span class="fc" id="L580">                p.setElementAt(ihi, j, ptry[j]);</span>
            }
        }

<span class="fc" id="L584">        return ytry;</span>
    }

    /**
     * Swaps a and b values.
     *
     * @param a value.
     * @param b value.
     */
    private static void swap(final double[] a, final double[] b) {
<span class="fc" id="L594">        final var tmp = a[0];</span>
<span class="fc" id="L595">        a[0] = b[0];</span>
<span class="fc" id="L596">        b[0] = tmp;</span>
<span class="fc" id="L597">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>