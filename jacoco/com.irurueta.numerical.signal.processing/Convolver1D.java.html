<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Convolver1D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-numerical</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.numerical.signal.processing</a> &gt; <span class="el_source">Convolver1D.java</span></div><h1>Convolver1D.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.numerical.signal.processing;

/**
 * Convolves a 1D signal with a 1D kernel.
 */
public class Convolver1D {

    /**
     * Default constant value to use during convolution if CONSTANT_EDGE method
     * is being used for signal's edge extension.
     */
    public static final double DEFAULT_CONSTANT_VALUE = 0.0;

    /**
     * Default position of kernel center.
     */
    public static final int DEFAULT_KERNEL_CENTER = 0;

    /**
     * Default method to use for signal's edge extension.
     */
<span class="fc" id="L37">    public static final ConvolverEdgeMethod DEFAULT_EDGE_METHOD = ConvolverEdgeMethod.ZERO_EDGE;</span>

    /**
     * Signal to be convolved.
     */
    private double[] signal;

    /**
     * Kernel to convolve the signal with.
     */
    private double[] kernel;

    /**
     * Position of kernel center. Typical values are the start of kernel
     * (position 0) or the kernel's center. For the former, the edge extension
     * is applied only at the end of the resulting signal; for the latter, edge
     * extension is applied symmetrically at the beginning and end of the
     * resulting signal.
     */
<span class="fc" id="L56">    private int kernelCenter = DEFAULT_KERNEL_CENTER;</span>

    /**
     * Edge extension method to use during convolution when parts of the kernel
     * are required to lie outside the signal's boundaries.
     */
<span class="fc" id="L62">    private ConvolverEdgeMethod edgeMethod = DEFAULT_EDGE_METHOD;</span>

    /**
     * Constant value to use during edge extension when CONSTANT_EDGE method is
     * being used.
     */
<span class="fc" id="L68">    private double constantValue = DEFAULT_CONSTANT_VALUE;</span>

    /**
     * Listener in charge of attending events generated by this instance.
     */
    private Convolver1DListener listener;

    /**
     * Constructor.
     */
<span class="fc" id="L78">    public Convolver1D() {</span>
<span class="fc" id="L79">    }</span>

    /**
     * Constructor.
     *
     * @param signal signal to be convolved.
     * @param kernel kernel to convolve signal with.
     */
<span class="fc" id="L87">    public Convolver1D(final double[] signal, final double[] kernel) {</span>
<span class="fc" id="L88">        setSignal(signal);</span>
<span class="fc" id="L89">        setKernel(kernel);</span>
<span class="fc" id="L90">    }</span>

    /**
     * Gets signal to be convolved.
     *
     * @return signal to be convolved.
     */
    public double[] getSignal() {
<span class="fc" id="L98">        return signal;</span>
    }

    /**
     * Sets signal to be convolved.
     *
     * @param signal signal to be convolved.
     */
    public final void setSignal(final double[] signal) {
<span class="fc" id="L107">        this.signal = signal;</span>
<span class="fc" id="L108">    }</span>

    /**
     * Gets kernel to convolve the signal with.
     *
     * @return kernel to convolve the signal with.
     */
    public double[] getKernel() {
<span class="fc" id="L116">        return kernel;</span>
    }

    /**
     * Sets kernel to convolve the signal with.
     *
     * @param kernel kernel to convolve the signal with.
     */
    public final void setKernel(final double[] kernel) {
<span class="fc" id="L125">        this.kernel = kernel;</span>
<span class="fc" id="L126">    }</span>

    /**
     * Gets position of kernel center. Typical values are the start of kernel
     * (position 0) or the kernel's center. For the former, the edge extension
     * is applied only at the end of the resulting signal; for the latter, edge
     * extension is applied symmetrically at the beginning and end of the
     * resulting signal.
     *
     * @return position of kernel center.
     */
    public int getKernelCenter() {
<span class="fc" id="L138">        return kernelCenter;</span>
    }

    /**
     * Sets position of kernel center. Typical values are the start of kernel
     * (position 0) or the kernel's center. For the former, the edge extension
     * is applied only at the end of the resulting signal; for the latter, edge
     * extension is applied symmetrically at the beginning and end of the
     * resulting signal.
     *
     * @param kernelCenter position of kernel center.
     * @throws IllegalArgumentException if provided position is negative.
     */
    public void setKernelCenter(final int kernelCenter) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (kernelCenter &lt; 0) {</span>
<span class="fc" id="L153">            throw new IllegalArgumentException(&quot;kernel center must be zero or greater and within kernel's boundaries&quot;);</span>
        }

<span class="fc" id="L156">        this.kernelCenter = kernelCenter;</span>
<span class="fc" id="L157">    }</span>

    /**
     * Gets edge extension method to use during convolution when parts of the
     * kernel are required to lie outside the signal's boundaries.
     *
     * @return edge extension method.
     */
    public ConvolverEdgeMethod getEdgeMethod() {
<span class="fc" id="L166">        return edgeMethod;</span>
    }

    /**
     * Sets edge extension method to use during convolution when parts of the
     * kernel are required to lie outside the signal's boundaries.
     *
     * @param edgeMethod edge extension method.
     */
    public void setEdgeMethod(final ConvolverEdgeMethod edgeMethod) {
<span class="fc" id="L176">        this.edgeMethod = edgeMethod;</span>
<span class="fc" id="L177">    }</span>

    /**
     * Gets constant value to use during edge extension when CONSTANT_EDGE
     * method is being used.
     *
     * @return constant value to use during edge extension.
     */
    public double getConstantValue() {
<span class="fc" id="L186">        return constantValue;</span>
    }

    /**
     * Sets constant value to use during edge extension when CONSTANT_EDGE
     * method is being used.
     *
     * @param constantValue constant value to use during edge extension.
     */
    public void setConstantValue(final double constantValue) {
<span class="fc" id="L196">        this.constantValue = constantValue;</span>
<span class="fc" id="L197">    }</span>

    /**
     * Gets listener in charge of attending events generated by this instance.
     *
     * @return listener in charge of attending events generated by this
     * instance.
     */
    public Convolver1DListener getListener() {
<span class="fc" id="L206">        return listener;</span>
    }

    /**
     * Sets listener in charge of attending events generated by this instance.
     *
     * @param listener listener in charge of attending events generated by this
     *                 instance.
     */
    public void setListener(final Convolver1DListener listener) {
<span class="fc" id="L216">        this.listener = listener;</span>
<span class="fc" id="L217">    }</span>

    /**
     * Indicates whether this instance is ready to start a convolution.
     *
     * @return true if ready, false otherwise.
     */
    public boolean isReady() {
<span class="pc bpc" id="L225" title="1 of 8 branches missed.">        return signal != null &amp;&amp; kernel != null &amp;&amp; kernelCenter &gt;= 0 &amp;&amp; kernelCenter &lt; kernel.length;</span>
    }

    /**
     * Convolves provided signal with provided kernel using provided
     * configuration for edge extension.
     *
     * @return a new array containing result of convolution.
     */
    public double[] convolve() {
<span class="fc" id="L235">        return convolve(signal, kernel, kernelCenter, edgeMethod, constantValue, listener);</span>
    }

    /**
     * Convolves provided signal with provided kernel using provided
     * configuration for edge extension.
     *
     * @param result array where result of convolution will be stored. Must
     *               have the sum of the lengths of signal and kernel minus one.
     * @throws IllegalArgumentException if provided result array does not have
     *                                  proper length.
     */
    public void convolve(final double[] result) {
<span class="fc" id="L248">        convolve(signal, kernel, kernelCenter, edgeMethod, constantValue, result, listener);</span>
<span class="fc" id="L249">    }</span>

    /**
     * Convolves provided signal with provided kernel assuming a zero value
     * extension method and kernel center located at its origin.
     *
     * @param signal signal to be convolved.
     * @param kernel kernel used for convolution.
     * @return a new array containing result of convolution.
     */
    public static double[] convolve(final double[] signal, final double[] kernel) {
<span class="fc" id="L260">        return convolve(signal, kernel, DEFAULT_KERNEL_CENTER, (Convolver1DListener) null);</span>
    }

    /**
     * Convolves provided signal with provided kernel assuming a zero value
     * extension method and kernel center located at its origin.
     *
     * @param signal   signal to be convolved.
     * @param kernel   kernel used for convolution.
     * @param listener listener attending events generated during convolution.
     * @return a new array containing result of convolution.
     */
    public static double[] convolve(final double[] signal, final double[] kernel, final Convolver1DListener listener) {
<span class="fc" id="L273">        return convolve(signal, kernel, DEFAULT_KERNEL_CENTER, listener);</span>
    }

    /**
     * Convolves provided signal with provided kernel assuming a zero value
     * extension method and kernel center located at its origin.
     *
     * @param signal signal to be convolved.
     * @param kernel kernel used for convolution.
     * @param result array where result of convolution will be stored. Must
     *               have the sum of the lengths of signal and kernel minus one.
     * @throws IllegalArgumentException if provided result array does not
     *                                  have proper length.
     */
    public static void convolve(final double[] signal, final double[] kernel, final double[] result) {
<span class="fc" id="L288">        convolve(signal, kernel, DEFAULT_KERNEL_CENTER, result, null);</span>
<span class="fc" id="L289">    }</span>

    /**
     * Convolves provided signal with provided kernel assuming a zero value
     * extension method and kernel center located at its origin.
     *
     * @param signal   signal to be convolved.
     * @param kernel   kernel used for convolution.
     * @param result   array where result of convolution will be stored. Must
     *                 have the sum of the lengths of signal and kernel minus one.
     * @param listener listener attending events generated during convolution.
     * @throws IllegalArgumentException if provided result array does not
     *                                  have proper length.
     */
    public static void convolve(final double[] signal, final double[] kernel, final double[] result,
                                final Convolver1DListener listener) {
<span class="fc" id="L305">        convolve(signal, kernel, DEFAULT_KERNEL_CENTER, result, listener);</span>
<span class="fc" id="L306">    }</span>

    /**
     * Convolves provided signal with provided kernel assuming a zero value
     * extension method.
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel used for convolution.
     * @param kernelCenter position of kernel center. This determines how
     *                     signal's edge extension is applied. Must be a value within kernel's
     *                     boundaries.
     * @return a new array containing result of convolution.
     * @throws IllegalArgumentException if kernel center is not within kernel's
     *                                  boundaries.
     */
    public static double[] convolve(final double[] signal, final double[] kernel, final int kernelCenter) {
<span class="fc" id="L322">        return convolve(signal, kernel, kernelCenter, (Convolver1DListener) null);</span>
    }

    /**
     * Convolves provided signal with provided kernel assuming a zero value
     * extension method.
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel used for convolution.
     * @param kernelCenter position of kernel center. This determines how
     *                     signal's edge extension is applied. Must be a value within kernel's
     *                     boundaries.
     * @param listener     listener attending events generated during convolution.
     * @return a new array containing result of convolution.
     * @throws IllegalArgumentException if kernel center is not within kernel's
     *                                  boundaries.
     */
    public static double[] convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                    final Convolver1DListener listener) {
<span class="fc" id="L341">        return convolve(signal, kernel, kernelCenter, DEFAULT_EDGE_METHOD, listener);</span>
    }

    /**
     * Convolves provided signal with provided kernel assuming a zero value
     * extension method.
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel used for convolution.
     * @param kernelCenter position of kernel center. This determines how
     *                     signal's edge extension is applied. Must be a value within kernel's
     *                     boundaries.
     * @param result       array where result of convolution will be stored. Must
     *                     have the sum of the lengths of signal and kernel minus one.
     * @throws IllegalArgumentException if provided result array does not
     *                                  have proper length or if kernel center is not within kernel's boundaries.
     */
    public static void convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                final double[] result) {
<span class="fc" id="L360">        convolve(signal, kernel, kernelCenter, result, null);</span>
<span class="fc" id="L361">    }</span>

    /**
     * Convolves provided signal with provided kernel assuming a zero value
     * extension method.
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel used for convolution.
     * @param kernelCenter position of kernel center. This determines how
     *                     signal's edge extension is applied. Must be a value within kernel's
     *                     boundaries.
     * @param result       array where result of convolution will be stored. Must
     *                     have the sum of the lengths of signal and kernel minus one.
     * @param listener     listener attending events generated during convolution.
     * @throws IllegalArgumentException if provided result array does not
     *                                  have proper length or if kernel center is not within kernel's boundaries.
     */
    public static void convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                final double[] result, final Convolver1DListener listener) {
<span class="fc" id="L380">        convolve(signal, kernel, kernelCenter, DEFAULT_EDGE_METHOD, result, listener);</span>
<span class="fc" id="L381">    }</span>

    /**
     * Convolves provided signal with provided kernel assuming a zero value when
     * constant edge extension is used (which makes it equivalent to zero
     * extension method).
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel used for convolution.
     * @param kernelCenter position of kernel center. This determines how
     *                     signal's edge extension is applied. Must be a value within kernel's
     *                     boundaries.
     * @param edgeMethod   edge extension method.
     * @return a new array containing result of convolution.
     * @throws IllegalArgumentException if kernel center is not within kernel's
     *                                  boundaries.
     */
    public static double[] convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                    final ConvolverEdgeMethod edgeMethod) {
<span class="fc" id="L400">        return convolve(signal, kernel, kernelCenter, edgeMethod, (Convolver1DListener) null);</span>
    }

    /**
     * Convolves provided signal with provided kernel assuming a zero value when
     * constant edge extension is used (which makes it equivalent to zero
     * extension method).
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel used for convolution.
     * @param kernelCenter position of kernel center. This determines how
     *                     signal's edge extension is applied. Must be a value within kernel's
     *                     boundaries.
     * @param edgeMethod   edge extension method.
     * @param listener     listener attending events generated during convolution.
     * @return a new array containing result of convolution.
     * @throws IllegalArgumentException if kernel center is not within kernel's
     *                                  boundaries.
     */
    public static double[] convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                    final ConvolverEdgeMethod edgeMethod, final Convolver1DListener listener) {
<span class="fc" id="L421">        return convolve(signal, kernel, kernelCenter, edgeMethod, DEFAULT_CONSTANT_VALUE, listener);</span>
    }

    /**
     * Convolves provided signal with provided kernel assuming a zero value when
     * constant edge extension is used (which makes it equivalent to zero
     * extension method).
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel used for convolution.
     * @param kernelCenter position of kernel center. This determines how
     *                     signal's edge extension is applied. Must be a value within kernel's
     *                     boundaries.
     * @param edgeMethod   edge extension method.
     * @param result       array where result of convolution will be stored. Must
     *                     have the sum of the lengths of signal and kernel minus one.
     * @throws IllegalArgumentException if provided result array does not
     *                                  have proper length or if kernel center is not within kernel's boundaries.
     */
    public static void convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                final ConvolverEdgeMethod edgeMethod, final double[] result) {
<span class="fc" id="L442">        convolve(signal, kernel, kernelCenter, edgeMethod, result, null);</span>
<span class="fc" id="L443">    }</span>

    /**
     * Convolves provided signal with provided kernel assuming a zero value when
     * constant edge extension is used (which makes it equivalent to zero
     * extension method).
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel used for convolution.
     * @param kernelCenter position of kernel center. This determines how
     *                     signal's edge extension is applied. Must be a value within kernel's
     *                     boundaries.
     * @param edgeMethod   edge extension method.
     * @param listener     listener attending events generated during convolution.
     * @param result       array where result of convolution will be stored. Must
     *                     have the sum of the lengths of signal and kernel minus one.
     * @throws IllegalArgumentException if provided result array does not
     *                                  have proper length or if kernel center is not within kernel's boundaries.
     */
    public static void convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                final ConvolverEdgeMethod edgeMethod, final double[] result,
                                final Convolver1DListener listener) {
<span class="fc" id="L465">        convolve(signal, kernel, kernelCenter, edgeMethod, DEFAULT_CONSTANT_VALUE, result, listener);</span>
<span class="fc" id="L466">    }</span>

    /**
     * Convolves provided signal with provided kernel.
     *
     * @param signal        signal to be convolved.
     * @param kernel        kernel used for convolution.
     * @param kernelCenter  position of kernel center. This determines how
     *                      signal's edge extension is applied. Must be a value within kernel's
     *                      boundaries.
     * @param edgeMethod    edge extension method.
     * @param constantValue constant value to be used for edge extension if
     *                      constant extension method is used.
     * @return a new array containing result of convolution.
     * @throws IllegalArgumentException if kernel center is not within kernel's
     *                                  boundaries.
     */
    public static double[] convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                    final ConvolverEdgeMethod edgeMethod, final double constantValue) {
<span class="fc" id="L485">        return convolve(signal, kernel, kernelCenter, edgeMethod, constantValue, (Convolver1DListener) null);</span>
    }

    /**
     * Convolves provided signal with provided kernel.
     *
     * @param signal        signal to be convolved.
     * @param kernel        kernel used for convolution.
     * @param kernelCenter  position of kernel center. This determines how
     *                      signal's edge extension is applied. Must be a value within kernel's
     *                      boundaries.
     * @param edgeMethod    edge extension method.
     * @param constantValue constant value to be used for edge extension if
     *                      constant extension method is used.
     * @param listener      listener attending events generated during convolution.
     * @return a new array containing result of convolution.
     * @throws IllegalArgumentException if kernel center is not within kernel's
     *                                  boundaries.
     */
    public static double[] convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                    final ConvolverEdgeMethod edgeMethod, final double constantValue,
                                    final Convolver1DListener listener) {

<span class="fc" id="L508">        final var result = new double[signal.length + kernel.length - 1];</span>
<span class="fc" id="L509">        convolve(signal, kernel, kernelCenter, edgeMethod, constantValue, result, listener);</span>
<span class="fc" id="L510">        return result;</span>
    }

    /**
     * Convolves provided signal with provided kernel.
     *
     * @param signal        signal to be convolved.
     * @param kernel        kernel used for convolution.
     * @param kernelCenter  position of kernel center. This determines how
     *                      signal's edge extension is applied. Must be a value within kernel's
     *                      boundaries.
     * @param edgeMethod    edge extension method.
     * @param constantValue constant value to be used for edge extension if
     *                      constant extension method is used.
     * @param result        array where result of convolution will be stored. Must
     *                      have the sum of the lengths of signal and kernel minus one.
     * @throws IllegalArgumentException if provided result array does not
     *                                  have proper length or if kernel center is not within kernel's boundaries.
     */
    public static void convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                final ConvolverEdgeMethod edgeMethod, final double constantValue,
                                final double[] result) {
<span class="fc" id="L532">        convolve(signal, kernel, kernelCenter, edgeMethod, constantValue, result, null);</span>
<span class="fc" id="L533">    }</span>

    /**
     * Convolves provided signal with provided kernel.
     *
     * @param signal        signal to be convolved.
     * @param kernel        kernel used for convolution.
     * @param kernelCenter  position of kernel center. This determines how
     *                      signal's edge extension is applied. Must be a value within kernel's
     *                      boundaries.
     * @param edgeMethod    edge extension method.
     * @param constantValue constant value to be used for edge extension if
     *                      constant extension method is used.
     * @param result        array where result of convolution will be stored. Must
     *                      have the sum of the lengths of signal and kernel minus one.
     * @param listener      listener attending events generated during convolution.
     * @throws IllegalArgumentException if provided result array does not
     *                                  have proper length or if kernel center is not within kernel's boundaries.
     */
    public static void convolve(final double[] signal, final double[] kernel, final int kernelCenter,
                                final ConvolverEdgeMethod edgeMethod, final double constantValue, final double[] result,
                                final Convolver1DListener listener) {
<span class="pc bpc" id="L555" title="1 of 4 branches missed.">        if (kernelCenter &lt; 0 || kernelCenter &gt;= kernel.length) {</span>
<span class="fc" id="L556">            throw new IllegalArgumentException(&quot;kernel center must be within kernel boundaries&quot;);</span>
        }
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (result.length != signal.length + kernel.length - 1) {</span>
<span class="fc" id="L559">            throw new IllegalArgumentException(</span>
                    &quot; result array must have a length equal to the sum of signal and kernel lengths minus one&quot;);
        }

<span class="fc bfc" id="L563" title="All 4 branches covered.">        switch (edgeMethod) {</span>
            case MIRROR_EDGE:
<span class="fc" id="L565">                internalConvolveMirror(signal, kernel, kernelCenter, result, listener);</span>
<span class="fc" id="L566">                break;</span>
            case REPEAT_EDGE:
<span class="fc" id="L568">                internalConvolveRepeat(signal, kernel, kernelCenter, result, listener);</span>
<span class="fc" id="L569">                break;</span>
            case CONSTANT_EDGE:
<span class="fc" id="L571">                internalConvolveConstant(signal, kernel, kernelCenter, constantValue, result, listener);</span>
<span class="fc" id="L572">                break;</span>
            case ZERO_EDGE:
            default:
<span class="fc" id="L575">                internalConvolveZero(signal, kernel, kernelCenter, result, listener);</span>
                break;
        }
<span class="fc" id="L578">    }</span>

    /**
     * Internal method to convolve signal using zero edge extension method.
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel to convolve with.
     * @param kernelCenter kernel center.
     * @param result       array where result is stored.
     * @param listener     listener attending events generated during convolution.
     */
    private static void internalConvolveZero(
            final double[] signal, final double[] kernel, final int kernelCenter, final double[] result,
            final Convolver1DListener listener) {
<span class="fc" id="L592">        final var kernelLength = kernel.length;</span>
<span class="fc" id="L593">        final var resultLength = result.length;</span>
        double accum;
        int signalPos;

<span class="fc bfc" id="L597" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L598">            listener.onStartConvolution();</span>
        }

<span class="fc bfc" id="L601" title="All 2 branches covered.">        for (var i = 0; i &lt; resultLength; i++) {</span>

<span class="fc" id="L603">            accum = 0.0;</span>
<span class="fc" id="L604">            signalPos = i - kernelCenter;</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">            for (var j = 0; j &lt; kernelLength; j++) {</span>
<span class="fc" id="L606">                final var signalValue = getSignalValueZero(signal, signalPos - j);</span>
<span class="fc" id="L607">                accum += signalValue * kernel[j];</span>
            }

<span class="fc" id="L610">            result[i] = accum;</span>

<span class="fc bfc" id="L612" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L613">                final var progress = (float) i / (float) resultLength;</span>
<span class="fc" id="L614">                listener.onConvolveProgressChange(progress);</span>
            }
        }

<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L619">            listener.onFinishConvolution();</span>
        }
<span class="fc" id="L621">    }</span>

    /**
     * Internal method to determine signal value even when a position outside
     * its boundaries is requested when zero edge extension is being used.
     *
     * @param signal signal to request a value for.
     * @param pos    requested position.
     * @return signal value when position is within boundaries or zero
     * otherwise.
     */
    protected static double getSignalValueZero(final double[] signal, final int pos) {
<span class="fc bfc" id="L633" title="All 4 branches covered.">        if (pos &gt;= 0 &amp;&amp; pos &lt; signal.length) {</span>
<span class="fc" id="L634">            return signal[pos];</span>
        } else {
<span class="fc" id="L636">            return 0.0;</span>
        }
    }

    /**
     * Internal method to convolve signal using constant value edge extension
     * method.
     *
     * @param signal        signal to be convolved.
     * @param kernel        kernel to convolve with.
     * @param kernelCenter  kernel center.
     * @param constantValue constant value to use for positions outside signal
     *                      boundaries.
     * @param result        array where result is stored.
     * @param listener      listener attending events generated during convolution.
     */
    private static void internalConvolveConstant(
            final double[] signal, final double[] kernel, final int kernelCenter, final double constantValue,
            final double[] result, final Convolver1DListener listener) {
<span class="fc" id="L655">        final var kernelLength = kernel.length;</span>
<span class="fc" id="L656">        final var resultLength = result.length;</span>
        double accum;
        int signalPos;

<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L661">            listener.onStartConvolution();</span>
        }

<span class="fc bfc" id="L664" title="All 2 branches covered.">        for (var i = 0; i &lt; resultLength; i++) {</span>

<span class="fc" id="L666">            accum = 0.0;</span>
<span class="fc" id="L667">            signalPos = i - kernelCenter;</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">            for (var j = 0; j &lt; kernelLength; j++) {</span>
<span class="fc" id="L669">                final var signalValue = getSignalValueConstant(signal, signalPos - j, constantValue);</span>
<span class="fc" id="L670">                accum += signalValue * kernel[j];</span>
            }

<span class="fc" id="L673">            result[i] = accum;</span>

<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L676">                final var progress = (float) i / (float) resultLength;</span>
<span class="fc" id="L677">                listener.onConvolveProgressChange(progress);</span>
            }
        }

<span class="fc bfc" id="L681" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L682">            listener.onFinishConvolution();</span>
        }
<span class="fc" id="L684">    }</span>

    /**
     * Internal method to determine signal value even when a position outside
     * its boundaries is requested for constant value edge extension.
     *
     * @param signal        signal to request a value for.
     * @param pos           requested position.
     * @param constantValue constant value to use when requesting a position
     *                      outside signal boundaries.
     * @return signal value when position is within boundaries or constant
     * value otherwise.
     */
    protected static double getSignalValueConstant(final double[] signal, final int pos, final double constantValue) {
<span class="fc bfc" id="L698" title="All 4 branches covered.">        if (pos &gt;= 0 &amp;&amp; pos &lt; signal.length) {</span>
<span class="fc" id="L699">            return signal[pos];</span>
        } else {
<span class="fc" id="L701">            return constantValue;</span>
        }
    }

    /**
     * Internal method to convolve signal using a repeat extension method.
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel to convolve with.
     * @param kernelCenter kernel center.
     * @param result       array where result is stored.
     * @param listener     listener attending events generated during convolution.
     */
    private static void internalConvolveRepeat(
            final double[] signal, final double[] kernel, final int kernelCenter, final double[] result,
            final Convolver1DListener listener) {
<span class="fc" id="L717">        final var kernelLength = kernel.length;</span>
<span class="fc" id="L718">        final var resultLength = result.length;</span>
        double accum;
        int signalPos;

<span class="fc bfc" id="L722" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L723">            listener.onStartConvolution();</span>
        }

<span class="fc bfc" id="L726" title="All 2 branches covered.">        for (var i = 0; i &lt; resultLength; i++) {</span>

<span class="fc" id="L728">            accum = 0.0;</span>
<span class="fc" id="L729">            signalPos = i - kernelCenter;</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">            for (var j = 0; j &lt; kernelLength; j++) {</span>
<span class="fc" id="L731">                final var signalValue = getSignalValueRepeat(signal, signalPos - j);</span>
<span class="fc" id="L732">                accum += signalValue * kernel[j];</span>
            }

<span class="fc" id="L735">            result[i] = accum;</span>

<span class="fc bfc" id="L737" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L738">                final var progress = (float) i / (float) resultLength;</span>
<span class="fc" id="L739">                listener.onConvolveProgressChange(progress);</span>
            }
        }

<span class="fc bfc" id="L743" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L744">            listener.onFinishConvolution();</span>
        }
<span class="fc" id="L746">    }</span>

    /**
     * Internal method to determine signal value even when a position outside
     * its boundaries is requested for repeat edge extension.
     *
     * @param signal signal to request a value for.
     * @param pos    requested position.
     * @return signal value assuming that signal is repeated indefinitely
     * outside its boundaries.
     */
    protected static double getSignalValueRepeat(final double[] signal, int pos) {
<span class="fc" id="L758">        final var signalLength = signal.length;</span>
<span class="fc" id="L759">        pos = pos % signalLength;</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (pos &lt; 0) {</span>
<span class="fc" id="L761">            pos += signalLength;</span>
        }
<span class="fc" id="L763">        return signal[pos];</span>
    }

    /**
     * Internal method to convolve signal using a mirror extension method.
     *
     * @param signal       signal to be convolved.
     * @param kernel       kernel to convolve with.
     * @param kernelCenter kernel center.
     * @param result       array where result is stored.
     * @param listener     listener attending events generated during convolution.
     */
    private static void internalConvolveMirror(
            final double[] signal, final double[] kernel, final int kernelCenter, final double[] result,
            final Convolver1DListener listener) {
<span class="fc" id="L778">        final var kernelLength = kernel.length;</span>
<span class="fc" id="L779">        final var resultLength = result.length;</span>
        double accum;
        int signalPos;

<span class="fc bfc" id="L783" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L784">            listener.onStartConvolution();</span>
        }

<span class="fc bfc" id="L787" title="All 2 branches covered.">        for (var i = 0; i &lt; resultLength; i++) {</span>

<span class="fc" id="L789">            accum = 0.0;</span>
<span class="fc" id="L790">            signalPos = i - kernelCenter;</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">            for (var j = 0; j &lt; kernelLength; j++) {</span>
<span class="fc" id="L792">                final var signalValue = getSignalValueMirror(signal, signalPos - j);</span>
<span class="fc" id="L793">                accum += signalValue * kernel[j];</span>
            }

<span class="fc" id="L796">            result[i] = accum;</span>

<span class="fc bfc" id="L798" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L799">                final var progress = (float) i / (float) resultLength;</span>
<span class="fc" id="L800">                listener.onConvolveProgressChange(progress);</span>
            }
        }

<span class="fc bfc" id="L804" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L805">            listener.onFinishConvolution();</span>
        }
<span class="fc" id="L807">    }</span>

    /**
     * Internal method to determine signal value even when a position outside
     * its boundaries is requested for mirror edge extension.
     *
     * @param signal signal to request a value for.
     * @param pos    requested position.
     * @return signal value when assuming that signal is mirrored outside its
     * boundaries.
     */
    protected static double getSignalValueMirror(double[] signal, int pos) {
<span class="fc" id="L819">        final var signalLength = signal.length;</span>
<span class="fc" id="L820">        var times = pos / signalLength;</span>

<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (pos &lt; 0) {</span>
<span class="fc" id="L823">            times = Math.abs(times);</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">            if (times == 0) {</span>
<span class="fc" id="L825">                times = 1;</span>
            }
<span class="fc" id="L827">            pos = 2 * signalLength * times + pos;</span>
        }

<span class="fc" id="L830">        times = pos / signalLength;</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">        final var reversed = (times % 2 != 0);</span>

<span class="fc" id="L833">        pos = pos % signalLength;</span>
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">        if (pos &lt; 0) {</span>
<span class="nc" id="L835">            pos += signalLength;</span>
        } else {
<span class="fc bfc" id="L837" title="All 2 branches covered.">            if (reversed) {</span>
                // reversed
<span class="fc" id="L839">                pos = signalLength - 1 - pos;</span>
            }
        }

<span class="fc" id="L843">        return signal[pos];</span>
    }

    /**
     * Interface defining events produced by this class.
     */
    public interface Convolver1DListener {
        /**
         * Called when convolution starts.
         */
        void onStartConvolution();

        /**
         * Called when convolution finishes.
         */
        void onFinishConvolution();

        /**
         * Called when convolution progress changes.
         *
         * @param progress convolution progress as a value between 0.0f and
         *                 1.0f.
         */
        void onConvolveProgressChange(final float progress);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>