<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KalmanFilter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-numerical</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.numerical.signal.processing</a> &gt; <span class="el_source">KalmanFilter.java</span></div><h1>KalmanFilter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.numerical.signal.processing;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.algebra.WrongSizeException;

import java.io.Serializable;

/**
 * Implementation of a Kalman filter.
 * This class contains the state of a Kalman kilter.
 * The state of a Kalman filter is updated by
 * &lt;code&gt;predict&lt;/code&gt; and &lt;code&gt;correct&lt;/code&gt; functions.
 * &lt;p&gt;
 * The source code, notation and formulae below are borrowed from the JKalman
 * tutorial &lt;a href=&quot;http://www.cs.unc.edu/~welch/kalman/&quot;&gt;[Welch95]&lt;/a&gt;:
 * &lt;pre&gt;
 * {@code
 * x&lt;sub&gt;k&lt;/sub&gt;=A*x&lt;sub&gt;k-1&lt;/sub&gt;+B*u&lt;sub&gt;k&lt;/sub&gt;+w&lt;sub&gt;k&lt;/sub&gt;
 * z&lt;sub&gt;k&lt;/sub&gt;=Hx&lt;sub&gt;k&lt;/sub&gt;+v&lt;sub&gt;k&lt;/sub&gt;,
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;where:
 * &lt;pre&gt;
 * {@code x&lt;sub&gt;k&lt;/sub&gt; (x&lt;sub&gt;k-1&lt;/sub&gt;)} - state of the system at the moment k (k-1)
 * {@code z&lt;sub&gt;k&lt;/sub&gt;} - measurement of the system state at the moment k
 * {@code u&lt;sub&gt;k&lt;/sub&gt;} - external control applied at the moment k
 * {@code w&lt;sub&gt;k&lt;/sub&gt;} and {@code v&lt;sub&gt;k&lt;/sub&gt;} are normally-distributed process and
 * measurement noise, respectively:
 * p(w) ~ N(0,Q)
 * p(v) ~ N(0,R),
 * that is,
 * Q - process noise covariance matrix, constant or variable,
 * R - measurement noise covariance matrix, constant or variable
 * &lt;/pre&gt;
 * &lt;p&gt;
 * In case of standard Kalman filter, all the matrices: A, B, H, Q and R
 * are initialized once after Kalman structure is allocated via constructor.
 * However, the same structure and the same functions may be used to simulate
 * extended Kalman filter by linearizing extended Kalman filter equation in the
 * current system state neighborhood, in this case A, B, H (and, probably,
 * Q and R) should be updated on every step.
 */
public class KalmanFilter implements Serializable {

    /**
     * Independent process noise variance assumed when no process noise
     * covariance matrix is provided.
     * The lower the process variance the smoother the estimated state will
     * typically be.
     */
    public static final double DEFAULT_PROCESS_NOISE_VARIANCE = 1e-6;

    /**
     * Independent measurement noise variance assumed when no measurement noise
     * covariance matrix is provided.
     */
    public static final double DEFAULT_MEASUREMENT_NOISE_VARIANCE = 1e-1;

    /**
     * Number of measurement vector dimensions (measure parameters).
     */
    private int mp;

    /**
     * Number of state vector dimensions (dynamic parameters).
     */
    private final int dp;

    /**
     * Number of control vector dimensions (control parameters).
     */
    private final int cp;

    /**
     * Predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)
     */
    private Matrix statePre;

    /**
     * Corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))
     */
    private Matrix statePost;

    /**
     * State transition matrix (A).
     */
    private Matrix transitionMatrix;

    /**
     * Control matrix (B) (it is not used if there is no control).
     */
    private Matrix controlMatrix;

    /**
     * Measurement matrix (H).
     */
    private Matrix measurementMatrix;

    /**
     * Process noise covariance matrix (Q).
     */
    private Matrix processNoiseCov;

    /**
     * Measurement noise covariance matrix (R).
     */
    private Matrix measurementNoiseCov;

    /**
     * Priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)
     */
    private Matrix errorCovPre;

    /**
     * Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)
     */
    private Matrix gain;

    /**
     * Posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)
     */
    private Matrix errorCovPost;

    // temporary matrices to be reused to avoid unnecessary re-allocations

    /**
     * Temporary matrix 1.
     */
    private final Matrix temp1;

    /**
     * Temporary matrix 2.
     */
    private Matrix temp2;

    /**
     * Temporary matrix 3.
     */
    private Matrix temp3;

    /**
     * Temporary matrix 4.
     */
    private Matrix temp4;

    /**
     * Temporary matrix 5.
     */
    private Matrix temp5;

    /**
     * Temporary matrix 6.
     */
    private Matrix temp6;

    /**
     * Temporary matrix 7.
     */
    private final Matrix temp7;

    /**
     * Temporary matrix 8.
     */
    private Matrix temp8;

    /**
     * Allocates a Kalman filter and all its matrices and initializes them.
     *
     * @param dynamParams   number of dynamic parameters (state vector dimensions).
     * @param measureParams number of measurement parameters (measurement vector
     *                      dimensions).
     * @param controlParams number of control parameters (control vector.
     *                      dimensions). If zero, no control parameters are used. If less than zero,
     *                      it is assumed that this is equal to the number of dynamic parameters.
     * @throws IllegalArgumentException  if either the number of dynamic or
     *                                   measurement parameters is zero or negative.
     * @throws SignalProcessingException if something else fails.
     */
    public KalmanFilter(final int dynamParams, final int measureParams, int controlParams)
<span class="fc" id="L197">            throws SignalProcessingException {</span>

<span class="fc bfc" id="L199" title="All 4 branches covered.">        if (dynamParams &lt;= 0 || measureParams &lt;= 0) {</span>
<span class="fc" id="L200">            throw new IllegalArgumentException(&quot;Kalman filter: Illegal dimensions&quot;);</span>
        }

<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (controlParams &lt; 0) {</span>
<span class="fc" id="L204">            controlParams = dynamParams;</span>
        }

        // init
<span class="fc" id="L208">        dp = dynamParams;</span>
<span class="fc" id="L209">        mp = measureParams;</span>
<span class="fc" id="L210">        cp = controlParams;</span>

        try {
<span class="fc" id="L213">            statePre = new Matrix(dp, 1);</span>

            // following variables must be initialized properly in advance
<span class="fc" id="L216">            statePost = new Matrix(dp, 1);</span>
<span class="fc" id="L217">            transitionMatrix = Matrix.identity(dp, dp);</span>

<span class="fc" id="L219">            processNoiseCov = Matrix.identity(dp, dp);</span>
<span class="fc" id="L220">            processNoiseCov.multiplyByScalar(DEFAULT_PROCESS_NOISE_VARIANCE);</span>

<span class="fc" id="L222">            measurementMatrix = Matrix.identity(mp, dp);</span>
<span class="fc" id="L223">            measurementNoiseCov = Matrix.identity(mp, mp);</span>
<span class="fc" id="L224">            measurementNoiseCov.multiplyByScalar(DEFAULT_MEASUREMENT_NOISE_VARIANCE);</span>

<span class="fc" id="L226">            errorCovPre = new Matrix(dp, dp);</span>
<span class="fc" id="L227">            errorCovPost = Matrix.identity(dp, dp);</span>

<span class="fc" id="L229">            gain = new Matrix(dp, mp);</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (cp &gt; 0) {</span>
<span class="fc" id="L232">                controlMatrix = new Matrix(dp, cp);</span>
            } else {
                // no control parameters
<span class="fc" id="L235">                controlMatrix = null;</span>
            }

<span class="fc" id="L238">            temp1 = new Matrix(dp, dp);</span>
<span class="fc" id="L239">            temp2 = new Matrix(mp, dp);</span>
<span class="fc" id="L240">            temp3 = new Matrix(mp, mp);</span>
<span class="fc" id="L241">            temp4 = new Matrix(mp, dp);</span>
<span class="fc" id="L242">            temp5 = new Matrix(mp, 1);</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">            if (cp &gt; 0) {</span>
<span class="fc" id="L245">                temp6 = new Matrix(dp, 1);</span>
            }

<span class="fc" id="L248">            temp7 = new Matrix(dp, dp);</span>
<span class="fc" id="L249">            temp8 = new Matrix(dp, mp);</span>
<span class="nc" id="L250">        } catch (final AlgebraException ex) {</span>
<span class="nc" id="L251">            throw new SignalProcessingException(ex);</span>
<span class="fc" id="L252">        }</span>
<span class="fc" id="L253">    }</span>

    /**
     * Constructor in case of no control parameters.
     *
     * @param dynamParams   number of dynamic parameters (state vector dimensions).
     * @param measureParams number of measurement parameters (measurement vector
     *                      dimensions).
     * @throws IllegalArgumentException  if either the number of dynamic or
     *                                   measurement parameters is zero or negative.
     * @throws SignalProcessingException if something else fails.
     */
    public KalmanFilter(final int dynamParams, final int measureParams) throws SignalProcessingException {
<span class="fc" id="L266">        this(dynamParams, measureParams, 0);</span>
<span class="fc" id="L267">    }</span>

    /**
     * Estimates subsequent model state without control parameters.
     *
     * @return estimated state.
     * @throws SignalProcessingException if something fails.
     * @see #predict(Matrix)
     */
    public Matrix predict() throws SignalProcessingException {
<span class="fc" id="L277">        return predict(null);</span>
    }

    /**
     * Estimates subsequent model state.
     * The function estimates the subsequent stochastic model state by its
     * current state and stores it at &lt;code&gt;statePre&lt;/code&gt;:
     * &lt;pre&gt;
     * {@code
     * x'&lt;sub&gt;k&lt;/sub&gt;=A*x&lt;sub&gt;k&lt;/sub&gt;+B*u&lt;sub&gt;k&lt;/sub&gt;
     * P'&lt;sub&gt;k&lt;/sub&gt;=A*P&lt;sub&gt;k-1&lt;/sub&gt;*A&lt;sup&gt;T&lt;/sup&gt; + Q,
     * where
     * x'&lt;sub&gt;k&lt;/sub&gt; is predicted state (statePre),
     * x&lt;sub&gt;k-1&lt;/sub&gt; is corrected state on the previous step (statePost)
     *     (should be initialized somehow in the beginning, zero vector by
     * default),
     * u&lt;sub&gt;k&lt;/sub&gt; is external control (&lt;code&gt;control&lt;/code&gt; parameter),
     * P'&lt;sub&gt;k&lt;/sub&gt; is prior error covariance matrix (error_cov_pre)
     * P&lt;sub&gt;k-1&lt;/sub&gt; is posteriori error covariance matrix on the previous
     * step (error_cov_post)
     *     (should be initialized somehow in the beginning, identity matrix by
     * default),
     * }
     * &lt;/pre&gt;
     *
     * @param control control vector (u&lt;sub&gt;k&lt;/sub&gt;), should be null if there is
     *                no external control (&lt;code&gt;controlParams&lt;/code&gt;=0). If provided and
     *                filter uses control parameters, it must be a 1 column matrix having
     *                cp rows (where cp = number of control parameters), otherwise a
     *                SignalProcessingException will be raised.
     * @return estimated state as a 1 column matrix having dp rows (where dp =
     * number of dynamic parameters).
     * @throws SignalProcessingException if something fails.
     */
    public Matrix predict(final Matrix control) throws SignalProcessingException {
        try {
            // (1) Project the state ahead
            // update the state: x'(k) = A*x(k)
<span class="fc" id="L315">            transitionMatrix.multiply(statePost, statePre);</span>
<span class="pc bpc" id="L316" title="3 of 4 branches missed.">            if (control != null &amp;&amp; cp &gt; 0) {</span>
                // x'(k) = x'(k) + B*u(k)
<span class="nc" id="L318">                controlMatrix.multiply(control, temp6);</span>
<span class="nc" id="L319">                statePre.add(temp6);</span>
            }

            // (2) Project the error covariance ahead
            // update error covariance matrices: temp1 = A * P(k)
<span class="fc" id="L324">            transitionMatrix.multiply(errorCovPost, temp1);</span>
            // P'(k) = temp1 * At + Q
<span class="fc" id="L326">            transitionMatrix.transpose(temp7);</span>
<span class="fc" id="L327">            temp1.multiply(temp7);</span>
<span class="fc" id="L328">            temp1.add(processNoiseCov);</span>
<span class="fc" id="L329">            errorCovPre = temp1;</span>

<span class="fc" id="L331">            return statePre;</span>
<span class="nc" id="L332">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L333">            throw new SignalProcessingException(e);</span>
        }
    }

    /**
     * Adjusts model state.
     * This method adjusts stochastic model state on the basis of the given
     * measurement of the model state:
     * &lt;pre&gt;
     * {@code
     * K&lt;sub&gt;k&lt;/sub&gt;=P'&lt;sub&gt;k&lt;/sub&gt;*H&lt;sup&gt;T&lt;/sup&gt;*(H*P'&lt;sub&gt;k&lt;/sub&gt;*H&lt;sup&gt;T&lt;/sup&gt;+R)&lt;sup&gt;-1&lt;/sup&gt;
     * x&lt;sub&gt;k&lt;/sub&gt;=x'&lt;sub&gt;k&lt;/sub&gt;+K&lt;sub&gt;k&lt;/sub&gt;*(z&lt;sub&gt;k&lt;/sub&gt;-H*x'&lt;sub&gt;k&lt;/sub&gt;)
     * P&lt;sub&gt;k&lt;/sub&gt;=(I-K&lt;sub&gt;k&lt;/sub&gt;*H)*P'&lt;sub&gt;k&lt;/sub&gt;
     * where
     * z&lt;sub&gt;k&lt;/sub&gt; - given measurement (&lt;code&gt;measurement&lt;/code&gt; parameter)
     * K&lt;sub&gt;k&lt;/sub&gt; - Kalman &quot;gain&quot; matrix.
     * }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The function stores adjusted state at &lt;code&gt;statePost&lt;/code&gt; and returns
     * it on output.
     *
     * @param measurement matrix containing the measurement vector. Matrix must
     *                    have 1 column and mp rows (mp = measurement parameters).
     * @return adjusted model state.
     * @throws SignalProcessingException if something fails.
     */
    public Matrix correct(final Matrix measurement) throws SignalProcessingException {
        try {
            // (1) compute the Kalman gain
            // temp2 = H*P'(k)
<span class="fc" id="L364">            measurementMatrix.multiply(errorCovPre, temp2);</span>

            // temp3 = temp2*Ht + R
<span class="fc" id="L367">            measurementMatrix.transpose(temp8);</span>
<span class="fc" id="L368">            temp2.multiply(temp8, temp3);</span>
<span class="fc" id="L369">            temp3.add(measurementNoiseCov);</span>

            // temp4 = inv(temp3)*temp2 = Kt(k)
            // which is also equivalent to:
            // temp4 = temp3.svd().getU().times(temp2)
<span class="fc" id="L374">            Utils.solve(temp3, temp2, temp4);</span>

            // K(k)
<span class="fc" id="L377">            temp4.transpose();</span>
<span class="fc" id="L378">            gain = temp4;</span>

            // (2) Update estimate with measurement z(k)
            //temp5 = z(k) - H*x'(k)
<span class="fc" id="L382">            measurementMatrix.multiply(statePre, temp5);</span>
<span class="fc" id="L383">            temp5.multiplyByScalar(-1.0);</span>
<span class="fc" id="L384">            temp5.add(measurement);</span>

            // x(k) = x'(k) + K(k)*temp5
<span class="fc" id="L387">            gain.multiply(temp5, statePost);</span>
<span class="fc" id="L388">            statePost.add(statePre);</span>

            // (3) Update the error covariance
            // P(x) = P'(k) - K(k)*temp2
<span class="fc" id="L392">            gain.multiply(temp2, errorCovPost);</span>
<span class="fc" id="L393">            errorCovPost.multiplyByScalar(-1.0);</span>
<span class="fc" id="L394">            errorCovPost.add(errorCovPre);</span>

<span class="fc" id="L396">            return statePost;</span>
<span class="nc" id="L397">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L398">            throw new SignalProcessingException(e);</span>
        }
    }

    /**
     * Obtains the number of measurement vector dimensions (measure parameters).
     *
     * @return number of measurement vector dimensions (measure parameters)
     */
    public int getMeasureParameters() {
<span class="fc" id="L408">        return mp;</span>
    }

    /**
     * Sets the number of measurement vector dimensions (measure parameters).
     *
     * @param measureParameters number of measurement vector dimensions (measure
     *                          parameters).
     *                          NOTE: when resetting number of measure parameters, the measurement noise
     *                          covariance matrix and the measurement matrix get reset to their default
     *                          values having the required new size. Please, make sure those matrices
     *                          are reset to their proper values after calling this method.
     * @throws IllegalArgumentException  if provided value is zero or negative.
     * @throws SignalProcessingException if something else fails
     */
    public void setMeasureParameters(final int measureParameters) throws SignalProcessingException {
<span class="fc bfc" id="L424" title="All 2 branches covered.">        if (measureParameters &lt;= 0) {</span>
<span class="fc" id="L425">            throw new IllegalArgumentException(&quot;&quot;);</span>
        }
<span class="fc" id="L427">        mp = measureParameters;</span>

        try {
<span class="fc" id="L430">            measurementMatrix = Matrix.identity(mp, dp);</span>
<span class="fc" id="L431">            measurementNoiseCov = Matrix.identity(mp, mp);</span>
<span class="fc" id="L432">            measurementNoiseCov.multiplyByScalar(DEFAULT_MEASUREMENT_NOISE_VARIANCE);</span>

<span class="fc" id="L434">            gain = new Matrix(dp, mp);</span>

<span class="fc" id="L436">            temp2 = new Matrix(mp, dp);</span>
<span class="fc" id="L437">            temp3 = new Matrix(mp, mp);</span>
<span class="fc" id="L438">            temp4 = new Matrix(mp, dp);</span>
<span class="fc" id="L439">            temp5 = new Matrix(mp, 1);</span>

<span class="fc" id="L441">            temp8 = new Matrix(dp, mp);</span>
<span class="nc" id="L442">        } catch (final WrongSizeException e) {</span>
<span class="nc" id="L443">            throw new SignalProcessingException(e);</span>
<span class="fc" id="L444">        }</span>
<span class="fc" id="L445">    }</span>

    /**
     * Obtains the number of state vector dimensions (dynamic parameters).
     *
     * @return number of state vector dimensions (dynamic parameters)
     */
    public int getDynamicParameters() {
<span class="fc" id="L453">        return dp;</span>
    }

    /**
     * Obtains the number of control vector dimensions (control parameters).
     *
     * @return number of control vector dimensions (control parameters)
     */
    public int getControlParameters() {
<span class="fc" id="L462">        return cp;</span>
    }

    /**
     * Obtains predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k).
     * It is a column matrix having 1 column and dp rows, where dp is the
     * number of dynamic parameters
     *
     * @return predicted state
     */
    public Matrix getStatePre() {
<span class="fc" id="L473">        return statePre;</span>
    }

    /**
     * Sets predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k).
     * Provided matrix must have 1 column and dp rows, where dp is the number
     * of dynamic parameters set for this Kalman filter instance.
     * This setter method can be used for initial setup purposes.
     *
     * @param statePre new predicted state.
     * @throws IllegalArgumentException if provided matrix does not have 1
     *                                  column and dp rows
     */
    public void setStatePre(final Matrix statePre) {
<span class="fc bfc" id="L487" title="All 4 branches covered.">        if (statePre.getColumns() != 1 || statePre.getRows() != dp) {</span>
<span class="fc" id="L488">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L490">        this.statePre = statePre;</span>
<span class="fc" id="L491">    }</span>

    /**
     * Obtains corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k)).
     * It is a column matrix having 1 column and dp rows, where dp is the
     * number of dynamic parameters
     *
     * @return corrected state
     */
    public Matrix getStatePost() {
<span class="fc" id="L501">        return statePost;</span>
    }

    /**
     * Sets corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k)).
     * Provided matrix must have 1 column and dp rows, where dp is the number
     * of dynamic parameters set for this Kalman filter instance.
     * This setter method can be used for initial setup purposes.
     *
     * @param statePost new corrected state
     * @throws IllegalArgumentException if provided matrix does not have 1
     *                                  column and dp rows
     */
    public void setStatePost(final Matrix statePost) {
<span class="fc bfc" id="L515" title="All 4 branches covered.">        if (statePost.getColumns() != 1 || statePost.getRows() != dp) {</span>
<span class="fc" id="L516">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L518">        this.statePost = statePost;</span>
<span class="fc" id="L519">    }</span>

    /**
     * Obtains the state transition matrix (A).
     * It is a square matrix having dp rows and columns, where dp is equal to
     * the number of dynamic parameters.
     * This matrix defines how the system transitions to a new state for a given
     * previous state. It is used for prediction purposes
     *
     * @return state transition matrix
     */
    public Matrix getTransitionMatrix() {
<span class="fc" id="L531">        return transitionMatrix;</span>
    }

    /**
     * Sets the state transition matrix (A).
     * It must be a square matrix having dp rows and columns, where dp is equal
     * to the number of dynamic parameters set for this instance.
     * This matrix defines how the system transitions to a new state for a given
     * previous state. It is used for prediction purposes.
     * This setter method can be used for initial setup purposes.
     *
     * @param transitionMatrix new state transition matrix
     * @throws IllegalArgumentException if provided matrix does not have dp rows
     *                                  and columns
     */
    public void setTransitionMatrix(final Matrix transitionMatrix) {
<span class="fc bfc" id="L547" title="All 4 branches covered.">        if (transitionMatrix.getRows() != dp || transitionMatrix.getColumns() != dp) {</span>
<span class="fc" id="L548">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L550">        this.transitionMatrix = transitionMatrix;</span>
<span class="fc" id="L551">    }</span>

    /**
     * Obtains the control matrix (B) (it is not used if there is no control).
     * It's a matrix having dp rows and cp columns, where dp is the number of
     * dynamic parameters and cp is the number of control parameters.
     *
     * @return control matrix
     */
    public Matrix getControlMatrix() {
<span class="fc" id="L561">        return controlMatrix;</span>
    }

    /**
     * Sets the control matrix (B) (it is not used if there is no control).
     * Provided matrix must have dp rows and cp columns, where dp is the number
     * of dynamic parameters and cp is the number of control parameters set for
     * this Kalman filter instance.
     * This setter method can be used for initial setup purposes.
     *
     * @param controlMatrix new control matrix to be set, or null if no control
     *                      parameters are set
     * @throws IllegalArgumentException if provided matrix does not have dp
     *                                  rows and cp columns
     */
    public void setControlMatrix(final Matrix controlMatrix) {
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        if (cp &gt; 0) {</span>
<span class="pc bpc" id="L578" title="1 of 6 branches missed.">            if (controlMatrix == null || (controlMatrix.getRows() != dp || controlMatrix.getColumns() != cp)) {</span>
<span class="fc" id="L579">                throw new IllegalArgumentException();</span>
            }
        } else {
            // control matrix cannot be set
<span class="nc" id="L583">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L585">        this.controlMatrix = controlMatrix;</span>
<span class="fc" id="L586">    }</span>

    /**
     * Obtains measurement matrix (H).
     * It's a matrix having mp rows and dp columns, where mp is the number
     * of measurement parameters and dp is the number of dynamic parameters of
     * the system state.
     * This matrix relates obtained measures to the actual system state when a
     * given model is known in advance. If no model is known and measures
     * directly indicate the system state, then this matrix must be the
     * identity.
     *
     * @return measurement matrix
     */
    public Matrix getMeasurementMatrix() {
<span class="fc" id="L601">        return measurementMatrix;</span>
    }

    /**
     * Sets measurement matrix (H).
     * Provided matrix must have mp rows and dp columns, where mp is the number
     * of measurement parameters and dp is the number of dynamic parameters of
     * the system state.
     * This matrix relates obtained measures to the actual system state when a
     * given model is known in advance. If no model is known and measures
     * directly indicate the system state, then this matrix must be the
     * identity.
     * This setter method can be used for initial setup purposes.
     *
     * @param measurementMatrix measurement matrix
     * @throws IllegalArgumentException if provided matrix does not have mp rows
     *                                  and dp columns.
     */
    public void setMeasurementMatrix(final Matrix measurementMatrix) {
<span class="fc bfc" id="L620" title="All 4 branches covered.">        if (measurementMatrix.getRows() != mp || measurementMatrix.getColumns() != dp) {</span>
<span class="fc" id="L621">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L623">        this.measurementMatrix = measurementMatrix;</span>
<span class="fc" id="L624">    }</span>

    /**
     * Obtains the process noise covariance matrix (Q).
     * This is a covariance matrix indicating the correlations of the amount of
     * error in the system state.
     * It is a square symmetric matrix having dp rows and columns, where dp is
     * the number of dynamic parameters containing the system state.
     *
     * @return the process noise covariance matrix
     */
    public Matrix getProcessNoiseCov() {
<span class="fc" id="L636">        return processNoiseCov;</span>
    }

    /**
     * Sets the process noise covariance matrix (Q).
     * This is a covariance matrix indicating the correlations of the amount of
     * error in the system state.
     * It must be provided a square symmetric matrix having dp rows and columns,
     * where dp is the number of dynamic parameters containing the system state
     * for this instance of a Kalman filter.
     * This setter method can be used for initial setup purposes, however
     * typically the process noise is difficult to determine. This matrix is
     * generally constructed intuitively so that un-modelled dynamics and
     * parameter uncertainties are modeled as process noise generally. If
     * the process noise is unknown, just leave the default value or provide
     * a diagonal matrix with the desired level of variance Q, where a low Q
     * variance indicates confidence that any unknown noise terms and/or
     * modelling errors are small to negligible, and higher Q allows the tracker
     * to follow the state despite unknown noise and/or model errors.
     *
     * @param processNoiseCov process noise covariance matrix
     * @throws IllegalArgumentException if provided matrix does not have dp
     *                                  rows and columns, or it is not symmetric
     */
    public void setProcessNoiseCov(final Matrix processNoiseCov) {
<span class="fc bfc" id="L661" title="All 4 branches covered.">        if (processNoiseCov.getRows() != dp || processNoiseCov.getColumns() != dp</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">                || !Utils.isSymmetric(processNoiseCov)) {</span>
<span class="fc" id="L663">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L666">        this.processNoiseCov = processNoiseCov;</span>
<span class="fc" id="L667">    }</span>

    /**
     * Obtains the measurement noise covariance matrix (R).
     * This is a covariance matrix indicating the correlations of the amount of
     * error in the measures taken from the system.
     * It is a square symmetric matrix having mp rows and columns, where mp is
     * the number of measurement parameters.
     * Typically, this matrix can be easily obtained by processing the
     * measurements while the output of the system is held constant. In this
     * case, only noise remains in the data after its mean is removed.
     * The covariance can be calculated easily from the remaining portion of the
     * data.
     *
     * @return the measurement noise covariance matrix
     */
    public Matrix getMeasurementNoiseCov() {
<span class="fc" id="L684">        return measurementNoiseCov;</span>
    }

    /**
     * Sets the measurement noise covariance matrix (R).
     * This is a covariance matrix indicating the correlations of the amount of
     * error in the measures taken from the system.
     * Provided matrix must be a square symmetric matrix having mp rows and
     * columns, where mp is the number of measurement parameters.
     * Typically, this matrix can be easily obtained by processing the
     * measurements while the output of the system is held constant. In this
     * case, only noise remains in the data after its mean is removed.
     * The covariance can be calculated easily from the remaining portion of the
     * data.
     * This setter method can be used for initial setup purposes.
     *
     * @param measurementNoiseCov new measurement noise covariance matrix
     * @throws IllegalArgumentException if provided matrix does not have mp
     *                                  rows and columns, or it is not symmetric
     */
    public void setMeasurementNoiseCov(final Matrix measurementNoiseCov) {
<span class="fc bfc" id="L705" title="All 4 branches covered.">        if (measurementNoiseCov.getRows() != mp || measurementNoiseCov.getColumns() != mp</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">                || !Utils.isSymmetric(measurementNoiseCov)) {</span>
<span class="fc" id="L707">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L710">        this.measurementNoiseCov = measurementNoiseCov;</span>
<span class="fc" id="L711">    }</span>

    /**
     * Obtains the priori error estimate covariance matrix
     * (P'(k)): P'(k)=A*P(k-1)*At + Q).
     * It is a square symmetric matrix having dp rows and columns, where dp
     * is the number of dynamic parameters of the system state
     *
     * @return the priori error estimate covariance matrix
     */
    public Matrix getErrorCovPre() {
<span class="fc" id="L722">        return errorCovPre;</span>
    }

    /**
     * Sets the priori error estimate covariance matrix
     * (P'(k)): P'(k)=A*P(k-1)*At + Q).
     * Provided matrix must be square and symmetric having dp rows and columns,
     * where dp is the number of the dynamic parameters of the system state set
     * for this Kalman filter instance.
     * This setter method can be used for initial setup purposes, however this
     * value will rarely need to be set, and instead the getter method will be
     * used to obtain the error of the predicted system state once the filter
     * converges
     *
     * @param errorCovPre new priori error estimate covariance matrix
     * @throws IllegalArgumentException if provided matrix does not have dp rows
     *                                  and columns, or it is not symmetric
     */
    public void setErrorCovPre(final Matrix errorCovPre) {
<span class="fc bfc" id="L741" title="All 6 branches covered.">        if (errorCovPre.getRows() != dp || errorCovPre.getColumns() != dp || !Utils.isSymmetric(errorCovPre)) {</span>
<span class="fc" id="L742">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L744">        this.errorCovPre = errorCovPre;</span>
<span class="fc" id="L745">    }</span>

    /**
     * Obtains the Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R).
     * This matrix is used to correct the predicted state, if the gain values
     * are small then the filter is accurately tracking the system state and the
     * prediction error remains small too.
     * The gain matrix has dp rows and mp columns, where dp is the number of
     * dynamic parameters and mp is the number of measure parameters.
     *
     * @return the Kalman gain matrix
     */
    public Matrix getGain() {
<span class="fc" id="L758">        return gain;</span>
    }

    /**
     * Sets the Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R).
     * This matrix is used to correct the predicted state, if the gain values
     * are small then the filter is accurately tracking the system state and the
     * prediction error remains small too.
     * The gain matrix must have dp rows and mp columns, where dp is the number
     * of dynamic parameters and mp is the number of measure parameters set for
     * this Kalman filter instance.
     * This setter method can be used for initial setup purposes, however this
     * matrix rarely needs to be set, and instead it is better to let the filter
     * converge to the actual system state.
     *
     * @param gain new gain matrix
     * @throws IllegalArgumentException if provided matrix does not have dp rows
     *                                  and mp columns
     */
    public void setGain(final Matrix gain) {
<span class="fc bfc" id="L778" title="All 4 branches covered.">        if (gain.getRows() != dp || gain.getColumns() != mp) {</span>
<span class="fc" id="L779">            throw new IllegalArgumentException(&quot;Wrong matrix size&quot;);</span>
        }
<span class="fc" id="L781">        this.gain = gain;</span>
<span class="fc" id="L782">    }</span>

    /**
     * Obtains the posteriori error estimate covariance matrix
     * (P(k)): P(k)=(I-K(k)*H)*P'(k).
     * It is a square symmetric matrix having dp rows and columns, where dp
     * is the number of dynamic parameters of the system state
     *
     * @return the priori error estimate covariance matrix
     */
    public Matrix getErrorCovPost() {
<span class="fc" id="L793">        return errorCovPost;</span>
    }

    /**
     * Sets the posteriori error estimate covariance matrix
     * (P(k)): P(k)=(I-K(k)*H)*P'(k).
     * Provided matrix must be square and symmetric having dp rows and columns,
     * where dp is the number of the dynamic parameters of the system state set
     * for this Kalman filter instance.
     * This setter method can be used for initial setup purposes, however this
     * value will rarely need to be set, and instead the getter method will be
     * used to obtain the error of the posteriori system state once the filter
     * converges
     *
     * @param errorCovPost new posteriori error estimate covariance matrix
     * @throws IllegalArgumentException if provided matrix does not have dp rows
     *                                  and columns, or it is not symmetric
     */
    public void setErrorCovPost(final Matrix errorCovPost) {
<span class="fc bfc" id="L812" title="All 6 branches covered.">        if (errorCovPost.getRows() != dp || errorCovPost.getColumns() != dp || !Utils.isSymmetric(errorCovPost)) {</span>
<span class="fc" id="L813">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L815">        this.errorCovPost = errorCovPost;</span>
<span class="fc" id="L816">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>